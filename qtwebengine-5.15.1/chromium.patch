From 005c42f99558481eb4e552755fbb3097e20eb60f Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Tue, 2 Oct 2018 23:04:47 +0200
Subject: [PATCH 01/30] datapack: Byteswap metadata on big endian

---
 .../chromium/ui/base/resource/data_pack.cc    | 71 ++++++++++++-------
 1 file changed, 45 insertions(+), 26 deletions(-)

diff --git a/src/3rdparty/chromium/ui/base/resource/data_pack.cc b/src/3rdparty/chromium/ui/base/resource/data_pack.cc
index 53084ee3b..63185f1b7 100644
--- a/src/3rdparty/chromium/ui/base/resource/data_pack.cc
+++ b/src/3rdparty/chromium/ui/base/resource/data_pack.cc
@@ -165,16 +165,42 @@ bool MmapHasGzipHeader(const base::MemoryMappedFile* mmap) {
   return header_status == net::GZipHeader::COMPLETE_HEADER;
 }
 
+static inline uint16_t byteswap(uint16_t v) { return __builtin_bswap16(v); }
+static inline uint32_t byteswap(uint32_t v) { return __builtin_bswap32(v); }
+
+template<class T> class byteswapped_t {
+private:
+  T value;
+public:
+  inline byteswapped_t(T v) : value(byteswap(v)) { }
+  inline T operator=(T v) { value = byteswap(v); return v; }
+  inline T operator+=(T v) { v += byteswap(value); value = byteswap(v); return v; }
+  inline operator T() const { return byteswap(value); }
+};
+
+#if !defined(ARCH_CPU_LITTLE_ENDIAN)
+
+typedef byteswapped_t<uint16_t> uint16le_t;
+typedef byteswapped_t<uint32_t> uint32le_t;
+
+#else
+
+typedef uint16_t uint16le_t;
+typedef uint32_t uint32le_t;
+
+#endif
+
 }  // namespace
 
 namespace ui {
 
 #pragma pack(push, 2)
 struct DataPack::Entry {
-  uint16_t resource_id;
-  uint32_t file_offset;
+  uint16le_t resource_id;
+  uint32le_t file_offset;
 
   static int CompareById(const void* void_key, const void* void_entry) {
+    // Key is host endian
     uint16_t key = *reinterpret_cast<const uint16_t*>(void_key);
     const Entry* entry = reinterpret_cast<const Entry*>(void_entry);
     return key - entry->resource_id;
@@ -182,10 +208,11 @@ struct DataPack::Entry {
 };
 
 struct DataPack::Alias {
-  uint16_t resource_id;
-  uint16_t entry_index;
+  uint16le_t resource_id;
+  uint16le_t entry_index;
 
   static int CompareById(const void* void_key, const void* void_entry) {
+    // Key is host endian
     uint16_t key = *reinterpret_cast<const uint16_t*>(void_key);
     const Alias* entry = reinterpret_cast<const Alias*>(void_entry);
     return key - entry->resource_id;
@@ -322,7 +349,7 @@ bool DataPack::LoadImpl(std::unique_ptr<DataPack::DataSource> data_source) {
   // Parse the version and check for truncated header.
   uint32_t version = 0;
   if (data_length > sizeof(version))
-    version = reinterpret_cast<const uint32_t*>(data)[0];
+    version = reinterpret_cast<const uint32le_t*>(data)[0];
   size_t header_length =
       version == kFileFormatV4 ? kHeaderLengthV4 : kHeaderLengthV5;
   if (version == 0 || data_length < header_length) {
@@ -333,14 +360,14 @@ bool DataPack::LoadImpl(std::unique_ptr<DataPack::DataSource> data_source) {
 
   // Parse the header of the file.
   if (version == kFileFormatV4) {
-    resource_count_ = reinterpret_cast<const uint32_t*>(data)[1];
+    resource_count_ = reinterpret_cast<const uint32le_t*>(data)[1];
     alias_count_ = 0;
     text_encoding_type_ = static_cast<TextEncodingType>(data[8]);
   } else if (version == kFileFormatV5) {
     // Version 5 added the alias table and changed the header format.
     text_encoding_type_ = static_cast<TextEncodingType>(data[4]);
-    resource_count_ = reinterpret_cast<const uint16_t*>(data)[4];
-    alias_count_ = reinterpret_cast<const uint16_t*>(data)[5];
+    resource_count_ = reinterpret_cast<const uint16le_t*>(data)[4];
+    alias_count_ = reinterpret_cast<const uint16le_t*>(data)[5];
   } else {
     LOG(ERROR) << "Bad data pack version: got " << version << ", expected "
                << kFileFormatV4 << " or " << kFileFormatV5;
@@ -420,12 +447,6 @@ bool DataPack::HasResource(uint16_t resource_id) const {
 
 bool DataPack::GetStringPiece(uint16_t resource_id,
                               base::StringPiece* data) const {
-  // It won't be hard to make this endian-agnostic, but it's not worth
-  // bothering to do right now.
-#if !defined(ARCH_CPU_LITTLE_ENDIAN)
-#error "datapack assumes little endian"
-#endif
-
   const Entry* target = LookupEntryById(resource_id);
   if (!target)
     return false;
@@ -491,9 +512,6 @@ void DataPack::CheckForDuplicateResources(
 bool DataPack::WritePack(const base::FilePath& path,
                          const std::map<uint16_t, base::StringPiece>& resources,
                          TextEncodingType text_encoding_type) {
-#if !defined(ARCH_CPU_LITTLE_ENDIAN)
-#error "datapack assumes little endian"
-#endif
   if (text_encoding_type != UTF8 && text_encoding_type != UTF16 &&
       text_encoding_type != BINARY) {
     LOG(ERROR) << "Invalid text encoding type, got " << text_encoding_type
@@ -511,7 +529,7 @@ bool DataPack::WritePack(const base::FilePath& path,
   if (!file.valid())
     return false;
 
-  uint32_t encoding = static_cast<uint32_t>(text_encoding_type);
+  uint32le_t encoding = static_cast<uint32le_t>(text_encoding_type);
 
   // Build a list of final resource aliases, and an alias map at the same time.
   std::vector<uint16_t> resource_ids;
@@ -538,13 +556,14 @@ bool DataPack::WritePack(const base::FilePath& path,
 
   // These values are guaranteed to fit in a uint16_t due to the earlier
   // check of |resources_count|.
-  const uint16_t alias_count = static_cast<uint16_t>(aliases.size());
-  const uint16_t entry_count = static_cast<uint16_t>(resource_ids.size());
+  const uint16le_t alias_count = static_cast<uint16le_t>(aliases.size());
+  const uint16le_t entry_count = static_cast<uint16le_t>(resource_ids.size());
   DCHECK_EQ(static_cast<size_t>(entry_count) + static_cast<size_t>(alias_count),
             resources_count);
 
-  file.Write(&kFileFormatV5, sizeof(kFileFormatV5));
-  file.Write(&encoding, sizeof(uint32_t));
+  uint32le_t version = kFileFormatV5;
+  file.Write(&version, sizeof(version));
+  file.Write(&encoding, sizeof(uint32le_t));
   file.Write(&entry_count, sizeof(entry_count));
   file.Write(&alias_count, sizeof(alias_count));
 
@@ -552,8 +571,8 @@ bool DataPack::WritePack(const base::FilePath& path,
   // last item so we can compute the size of the list item.
   const uint32_t index_length = (entry_count + 1) * sizeof(Entry);
   const uint32_t alias_table_length = alias_count * sizeof(Alias);
-  uint32_t data_offset = kHeaderLengthV5 + index_length + alias_table_length;
-  for (const uint16_t resource_id : resource_ids) {
+  uint32le_t data_offset = kHeaderLengthV5 + index_length + alias_table_length;
+  for (const uint16le_t resource_id : resource_ids) {
     file.Write(&resource_id, sizeof(resource_id));
     file.Write(&data_offset, sizeof(data_offset));
     data_offset += resources.find(resource_id)->second.length();
@@ -561,13 +580,13 @@ bool DataPack::WritePack(const base::FilePath& path,
 
   // We place an extra entry after the last item that allows us to read the
   // size of the last item.
-  const uint16_t resource_id = 0;
+  const uint16le_t resource_id = 0;
   file.Write(&resource_id, sizeof(resource_id));
   file.Write(&data_offset, sizeof(data_offset));
 
   // Write the aliases table, if any. Note: |aliases| is an std::map,
   // ensuring values are written in increasing order.
-  for (const std::pair<uint16_t, uint16_t>& alias : aliases) {
+  for (const std::pair<uint16le_t, uint16le_t> alias : aliases) {
     file.Write(&alias, sizeof(alias));
   }
 
-- 
2.26.2


From 73ba13a2f1a3749a1d565a1dee0d63c780fc8579 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Tue, 2 Oct 2018 23:15:57 +0200
Subject: [PATCH 02/30] i18n: Use correct ICU data file

---
 src/3rdparty/chromium/base/i18n/icu_util.cc | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/src/3rdparty/chromium/base/i18n/icu_util.cc b/src/3rdparty/chromium/base/i18n/icu_util.cc
index e19f6dd8b..10b842a9b 100644
--- a/src/3rdparty/chromium/base/i18n/icu_util.cc
+++ b/src/3rdparty/chromium/base/i18n/icu_util.cc
@@ -75,8 +75,13 @@ wchar_t g_debug_icu_pf_filename[_MAX_PATH];
 // No need to change the filename in multiple places (gyp files, windows
 // build pkg configurations, etc). 'l' stands for Little Endian.
 // This variable is exported through the header file.
+#if defined(ARCH_CPU_LITTLE_ENDIAN)
 const char kIcuDataFileName[] = "icudtl.dat";
 const char kIcuExtraDataFileName[] = "icudtl_extra.dat";
+#else
+const char kIcuDataFileName[] = "icudtb.dat";
+const char kIcuExtraDataFileName[] = "icudtb_extra.dat";
+#endif
 
 #if defined(OS_ANDROID)
 const char kAssetsPathPrefix[] = "assets/";
-- 
2.26.2


From 65fa7f27dfa315bc675b6e8530ec3836c8ec1979 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Tue, 2 Oct 2018 23:18:47 +0200
Subject: [PATCH 03/30] blink: Update variable names in BE part of graphics
 code

---
 .../renderer/platform/graphics/gpu/webgl_image_conversion.cc  | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/3rdparty/chromium/third_party/blink/renderer/platform/graphics/gpu/webgl_image_conversion.cc b/src/3rdparty/chromium/third_party/blink/renderer/platform/graphics/gpu/webgl_image_conversion.cc
index 08aea5a6e..c813c7579 100644
--- a/src/3rdparty/chromium/third_party/blink/renderer/platform/graphics/gpu/webgl_image_conversion.cc
+++ b/src/3rdparty/chromium/third_party/blink/renderer/platform/graphics/gpu/webgl_image_conversion.cc
@@ -458,8 +458,8 @@ void Unpack<WebGLImageConversion::kDataFormatBGRA8, uint8_t, uint8_t>(
   for (unsigned i = 0; i < pixels_per_row; ++i) {
     uint32_t bgra = source32[i];
 #if defined(ARCH_CPU_BIG_ENDIAN)
-    uint32_t brMask = 0xff00ff00;
-    uint32_t gaMask = 0x00ff00ff;
+    uint32_t br_mask = 0xff00ff00;
+    uint32_t ga_mask = 0x00ff00ff;
 #else
     uint32_t br_mask = 0x00ff00ff;
     uint32_t ga_mask = 0xff00ff00;
-- 
2.26.2


From 78a45a631806f852df7b3a0ffa0fc9f4b80e87b6 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Tue, 2 Oct 2018 23:23:24 +0200
Subject: [PATCH 04/30] blink: Fix SaveRegisters_ppc64 for ABIv1

---
 .../blink/renderer/platform/heap/asm/SaveRegisters_ppc64.S    | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/src/3rdparty/chromium/third_party/blink/renderer/platform/heap/asm/SaveRegisters_ppc64.S b/src/3rdparty/chromium/third_party/blink/renderer/platform/heap/asm/SaveRegisters_ppc64.S
index ef6c3326e..5670453fc 100644
--- a/src/3rdparty/chromium/third_party/blink/renderer/platform/heap/asm/SaveRegisters_ppc64.S
+++ b/src/3rdparty/chromium/third_party/blink/renderer/platform/heap/asm/SaveRegisters_ppc64.S
@@ -39,6 +39,10 @@ PushAllRegisters:
         // Pass the first argument untouched in r3 and the
         // stack pointer to the callback.
         std 2, 24(1)
+#if _CALL_ELF == 1
+	ld 2, 8(4)
+	ld 4, 0(4)
+#endif
         mtctr 4
         mr 12, 4
         mr 4, 1
-- 
2.26.2


From b0f1dcc2dbba490aab616ecd42c3e47e3f7f5de2 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Tue, 2 Oct 2018 23:58:23 +0200
Subject: [PATCH 05/30] modp_b64: Set WORDS_BIGENDIAN on big endian

---
 src/3rdparty/chromium/third_party/modp_b64/BUILD.gn | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/src/3rdparty/chromium/third_party/modp_b64/BUILD.gn b/src/3rdparty/chromium/third_party/modp_b64/BUILD.gn
index 539abe158..981d8b65b 100644
--- a/src/3rdparty/chromium/third_party/modp_b64/BUILD.gn
+++ b/src/3rdparty/chromium/third_party/modp_b64/BUILD.gn
@@ -2,10 +2,16 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
+import("//build/config/host_byteorder.gni")
+
 static_library("modp_b64") {
   sources = [
     "modp_b64.cc",
     "modp_b64.h",
     "modp_b64_data.h",
   ]
+
+  if (host_byteorder == "big") {
+    defines = [ "WORDS_BIGENDIAN=1" ]
+  }
 }
-- 
2.26.2


From fbaf637415c09d6941c1c78b73e90e43c9f745c4 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Tue, 2 Oct 2018 23:59:08 +0200
Subject: [PATCH 06/30] modp_b64: Fix size datatype for modp_b64_decode on big
 endian

---
 src/3rdparty/chromium/third_party/modp_b64/modp_b64.cc | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/3rdparty/chromium/third_party/modp_b64/modp_b64.cc b/src/3rdparty/chromium/third_party/modp_b64/modp_b64.cc
index fdb8a40ec..a70b08090 100644
--- a/src/3rdparty/chromium/third_party/modp_b64/modp_b64.cc
+++ b/src/3rdparty/chromium/third_party/modp_b64/modp_b64.cc
@@ -118,7 +118,7 @@ size_t modp_b64_encode(char* dest, const char* str, size_t len)
 }
 
 #ifdef WORDS_BIGENDIAN   /* BIG ENDIAN -- SUN / IBM / MOTOROLA */
-int modp_b64_decode(char* dest, const char* src, int len)
+size_t modp_b64_decode(char* dest, const char* src, size_t len)
 {
     if (len == 0) return 0;
 
-- 
2.26.2


From 2483d676ffca6a5f1efa37575c1c5e04af7ea3c6 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Sun, 11 Nov 2018 16:55:43 +0100
Subject: [PATCH 07/30] pickle: Use same scalar size in ReadBool as in
 WriteBool

---
 src/3rdparty/chromium/base/pickle.cc | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/src/3rdparty/chromium/base/pickle.cc b/src/3rdparty/chromium/base/pickle.cc
index c8d784a3a..42bcccae4 100644
--- a/src/3rdparty/chromium/base/pickle.cc
+++ b/src/3rdparty/chromium/base/pickle.cc
@@ -82,7 +82,12 @@ inline const char* PickleIterator::GetReadPointerAndAdvance(
 }
 
 bool PickleIterator::ReadBool(bool* result) {
-  return ReadBuiltinType(result);
+  int int_result;
+  if (ReadBuiltinType(&int_result)) {
+    *result = static_cast<bool>(int_result);
+    return true;
+  } else
+    return false;
 }
 
 bool PickleIterator::ReadInt(int* result) {
-- 
2.26.2


From ae431147bdfefc12a5cba1ab524ee7f07538cc0f Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Mon, 12 Nov 2018 19:49:39 +0100
Subject: [PATCH 08/30] sha1: Remove byteswaps on big endian

These byteswaps are only needed on little endian.
---
 src/3rdparty/chromium/base/hash/sha1.cc | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/src/3rdparty/chromium/base/hash/sha1.cc b/src/3rdparty/chromium/base/hash/sha1.cc
index 4528d0bea..88e9d51aa 100644
--- a/src/3rdparty/chromium/base/hash/sha1.cc
+++ b/src/3rdparty/chromium/base/hash/sha1.cc
@@ -106,8 +106,10 @@ void SecureHashAlgorithm::Final() {
   Pad();
   Process();
 
+#if defined(ARCH_CPU_LITTLE_ENDIAN)
   for (auto& t : H)
     t = ByteSwap(t);
+#endif
 }
 
 void SecureHashAlgorithm::Update(const void* data, size_t nbytes) {
@@ -153,8 +155,10 @@ void SecureHashAlgorithm::Process() {
   //
   // W and M are in a union, so no need to memcpy.
   // memcpy(W, M, sizeof(M));
+#if defined(ARCH_CPU_LITTLE_ENDIAN)
   for (t = 0; t < 16; ++t)
     W[t] = ByteSwap(W[t]);
+#endif
 
   // b.
   for (t = 16; t < 80; ++t)
-- 
2.26.2


From f4ce3dc83697a679867f48c10950681bfeb75640 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Mon, 12 Nov 2018 19:51:58 +0100
Subject: [PATCH 09/30] unittest: Fix some tests exposing endianness to work on
 BE

---
 .../base/memory/shared_memory_mapping_unittest.cc   | 13 +++++++------
 .../chromium/base/metrics/bucket_ranges_unittest.cc |  9 +++++++++
 .../strings/string_number_conversions_unittest.cc   |  9 +++++++++
 3 files changed, 25 insertions(+), 6 deletions(-)

diff --git a/src/3rdparty/chromium/base/memory/shared_memory_mapping_unittest.cc b/src/3rdparty/chromium/base/memory/shared_memory_mapping_unittest.cc
index 52cd29441..72bc907b2 100644
--- a/src/3rdparty/chromium/base/memory/shared_memory_mapping_unittest.cc
+++ b/src/3rdparty/chromium/base/memory/shared_memory_mapping_unittest.cc
@@ -12,6 +12,7 @@
 #include "base/containers/span.h"
 #include "base/memory/read_only_shared_memory_region.h"
 #include "testing/gtest/include/gtest/gtest.h"
+#include "base/sys_byteorder.h"
 
 namespace base {
 
@@ -69,8 +70,8 @@ TEST_F(SharedMemoryMappingTest, SpanWithAutoDeducedElementCount) {
 
   for (size_t i = 0; i < write_span.size(); ++i)
     write_span[i] = i + 1;
-  EXPECT_EQ(0x04030201u, read_span[0]);
-  EXPECT_EQ(0x08070605u, read_span[1]);
+  EXPECT_EQ(HostToNet32(0x01020304u), read_span[0]);
+  EXPECT_EQ(HostToNet32(0x05060708u), read_span[1]);
 }
 
 TEST_F(SharedMemoryMappingTest, SpanWithExplicitElementCount) {
@@ -95,13 +96,13 @@ TEST_F(SharedMemoryMappingTest, SpanWithExplicitElementCount) {
 
   for (size_t i = 0; i < write_span.size(); ++i)
     write_span[i] = i + 1;
-  EXPECT_EQ(0x04030201u, read_span[0]);
-  EXPECT_EQ(0x08070605u, read_span[1]);
-  EXPECT_EQ(0x04030201u, read_span_2[0]);
+  EXPECT_EQ(HostToNet32(0x01020304u), read_span[0]);
+  EXPECT_EQ(HostToNet32(0x05060708u), read_span[1]);
+  EXPECT_EQ(HostToNet32(0x01020304u), read_span_2[0]);
 
   std::fill(write_span_2.begin(), write_span_2.end(), 0);
   EXPECT_EQ(0u, read_span[0]);
-  EXPECT_EQ(0x08070605u, read_span[1]);
+  EXPECT_EQ(HostToNet32(0x05060708u), read_span[1]);
   EXPECT_EQ(0u, read_span_2[0]);
 }
 
diff --git a/src/3rdparty/chromium/base/metrics/bucket_ranges_unittest.cc b/src/3rdparty/chromium/base/metrics/bucket_ranges_unittest.cc
index cabc1707c..91bbb0822 100644
--- a/src/3rdparty/chromium/base/metrics/bucket_ranges_unittest.cc
+++ b/src/3rdparty/chromium/base/metrics/bucket_ranges_unittest.cc
@@ -7,6 +7,7 @@
 #include <stdint.h>
 
 #include "testing/gtest/include/gtest/gtest.h"
+#include "base/sys_byteorder.h"
 
 namespace base {
 namespace {
@@ -64,13 +65,21 @@ TEST(BucketRangesTest, Checksum) {
   ranges.set_range(2, 2);
 
   ranges.ResetChecksum();
+#if defined(ARCH_CPU_LITTLE_ENDIAN)
   EXPECT_EQ(289217253u, ranges.checksum());
+#else
+  EXPECT_EQ(2767231596u, ranges.checksum());
+#endif
 
   ranges.set_range(2, 3);
   EXPECT_FALSE(ranges.HasValidChecksum());
 
   ranges.ResetChecksum();
+#if defined(ARCH_CPU_LITTLE_ENDIAN)
   EXPECT_EQ(2843835776u, ranges.checksum());
+#else
+  EXPECT_EQ(3556223738u, ranges.checksum());
+#endif
   EXPECT_TRUE(ranges.HasValidChecksum());
 }
 
diff --git a/src/3rdparty/chromium/base/strings/string_number_conversions_unittest.cc b/src/3rdparty/chromium/base/strings/string_number_conversions_unittest.cc
index 4a68c592f..7ae3fcc81 100644
--- a/src/3rdparty/chromium/base/strings/string_number_conversions_unittest.cc
+++ b/src/3rdparty/chromium/base/strings/string_number_conversions_unittest.cc
@@ -882,12 +882,21 @@ TEST(StringNumberConversionsTest, DoubleToString) {
   }
 
   // The following two values were seen in crashes in the wild.
+#if defined(ARCH_CPU_LITTLE_ENDIAN)
   const char input_bytes[8] = {0, 0, 0, 0, '\xee', '\x6d', '\x73', '\x42'};
+#else
+  const char input_bytes[8] = {'\x42', '\x73', '\x6d', '\xee', 0, 0, 0, 0};
+#endif
   double input = 0;
   memcpy(&input, input_bytes, base::size(input_bytes));
   EXPECT_EQ("1.335179083776e+12", NumberToString(input));
+#if defined(ARCH_CPU_LITTLE_ENDIAN)
   const char input_bytes2[8] =
       {0, 0, 0, '\xa0', '\xda', '\x6c', '\x73', '\x42'};
+#else
+  const char input_bytes2[8] =
+      {'\x42', '\x73', '\x6c', '\xda', '\xa0', 0, 0, 0};
+#endif
   input = 0;
   memcpy(&input, input_bytes2, base::size(input_bytes2));
   EXPECT_EQ("1.33489033216e+12", NumberToString(input));
-- 
2.26.2


From 33872f6e99890759ab485d8ae8a001ddfff2d2c9 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Sun, 17 Feb 2019 16:43:20 +0100
Subject: [PATCH 10/30] V4Rice: Fix LE dependency

---
 .../chromium/components/safe_browsing/db/v4_rice.cc    |  9 +++------
 .../components/safe_browsing/db/v4_rice_unittest.cc    | 10 ++++++++--
 2 files changed, 11 insertions(+), 8 deletions(-)

diff --git a/src/3rdparty/chromium/components/safe_browsing/db/v4_rice.cc b/src/3rdparty/chromium/components/safe_browsing/db/v4_rice.cc
index 547a40206..6478796ec 100644
--- a/src/3rdparty/chromium/components/safe_browsing/db/v4_rice.cc
+++ b/src/3rdparty/chromium/components/safe_browsing/db/v4_rice.cc
@@ -8,6 +8,7 @@
 #include "base/logging.h"
 #include "base/numerics/safe_math.h"
 #include "base/strings/stringprintf.h"
+#include "base/sys_byteorder.h"
 #include "build/build_config.h"
 #include "components/safe_browsing/db/v4_rice.h"
 
@@ -21,10 +22,6 @@ using ::google::protobuf::RepeatedField;
 using ::google::protobuf::int32;
 using ::google::protobuf::int64;
 
-#if !defined(ARCH_CPU_LITTLE_ENDIAN) || (ARCH_CPU_LITTLE_ENDIAN != 1)
-#error The code below assumes little-endianness.
-#endif
-
 namespace safe_browsing {
 
 namespace {
@@ -117,7 +114,7 @@ V4DecodeResult V4RiceDecoder::DecodePrefixes(const int64 first_value,
   out->reserve((num_entries + 1));
 
   base::CheckedNumeric<uint32_t> last_value(first_value);
-  out->push_back(htonl(last_value.ValueOrDie()));
+  out->push_back(base::ByteSwap(static_cast<uint32_t>(last_value.ValueOrDie())));
 
   if (num_entries > 0) {
     V4RiceDecoder decoder(rice_parameter, num_entries, encoded_data);
@@ -136,7 +133,7 @@ V4DecodeResult V4RiceDecoder::DecodePrefixes(const int64 first_value,
 
       // This flipping is done so that the decoded uint32 is interpreted
       // correcly as a string of 4 bytes.
-      out->push_back(htonl(last_value.ValueOrDie()));
+      out->push_back(base::ByteSwap(static_cast<uint32_t>(last_value.ValueOrDie())));
     }
   }
 
diff --git a/src/3rdparty/chromium/components/safe_browsing/db/v4_rice_unittest.cc b/src/3rdparty/chromium/components/safe_browsing/db/v4_rice_unittest.cc
index cfc369ceb..f53bf2741 100644
--- a/src/3rdparty/chromium/components/safe_browsing/db/v4_rice_unittest.cc
+++ b/src/3rdparty/chromium/components/safe_browsing/db/v4_rice_unittest.cc
@@ -6,6 +6,12 @@
 #include "base/logging.h"
 #include "testing/platform_test.h"
 
+#if defined(OS_WIN)
+#include <winsock2.h>
+#elif defined(OS_POSIX)
+#include <arpa/inet.h>
+#endif
+
 using ::google::protobuf::RepeatedField;
 using ::google::protobuf::int32;
 
@@ -247,7 +253,7 @@ TEST_F(V4RiceTest, TestDecoderPrefixesWithOneValue) {
   EXPECT_EQ(DECODE_SUCCESS,
             V4RiceDecoder::DecodePrefixes(0x69F67F51u, 2, 0, "", &out));
   EXPECT_EQ(1u, out.size());
-  EXPECT_EQ(0x69F67F51u, out[0]);
+  EXPECT_EQ(htonl(0x517FF669u), out[0]);
 }
 
 TEST_F(V4RiceTest, TestDecoderPrefixesWithMultipleValues) {
@@ -256,7 +262,7 @@ TEST_F(V4RiceTest, TestDecoderPrefixesWithMultipleValues) {
             V4RiceDecoder::DecodePrefixes(
                 5, 28, 3, "\xbf\xa8\x3f\xfb\xf\xf\x5e\x27\xe6\xc3\x1d\xc6\x38",
                 &out));
-  std::vector<uint32_t> expected = {5, 0xad934c0cu, 0x6ff67f56u, 0x81316fceu};
+  std::vector<uint32_t> expected = {htonl(0x05000000), htonl(0x0c4c93adu), htonl(0x567ff66fu), htonl(0xce6f3181u)};
   EXPECT_EQ(expected.size(), out.size());
   for (unsigned i = 0; i < expected.size(); i++) {
     EXPECT_EQ(expected[i], out[i]);
-- 
2.26.2


From 18df8c1e91da7f00c2709e79283fbcc1b836311a Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Sun, 17 Feb 2019 17:01:13 +0100
Subject: [PATCH 11/30] url::Canonicalize: Remove unportable reinterpret_cast

---
 src/3rdparty/chromium/url/url_canon_host.cc    | 3 +--
 src/3rdparty/chromium/url/url_canon_internal.h | 4 ++--
 2 files changed, 3 insertions(+), 4 deletions(-)

diff --git a/src/3rdparty/chromium/url/url_canon_host.cc b/src/3rdparty/chromium/url/url_canon_host.cc
index 9f3154779..08f417db4 100644
--- a/src/3rdparty/chromium/url/url_canon_host.cc
+++ b/src/3rdparty/chromium/url/url_canon_host.cc
@@ -135,8 +135,7 @@ bool DoSimpleHost(const INCHAR* host,
     if (source == '%') {
       // Unescape first, if possible.
       // Source will be used only if decode operation was successful.
-      if (!DecodeEscaped(host, &i, host_len,
-                         reinterpret_cast<unsigned char*>(&source))) {
+      if (!DecodeEscaped(host, &i, host_len, &source)) {
         // Invalid escaped character. There is nothing that can make this
         // host valid. We append an escaped percent so the URL looks reasonable
         // and mark as failed.
diff --git a/src/3rdparty/chromium/url/url_canon_internal.h b/src/3rdparty/chromium/url/url_canon_internal.h
index ba8b9ee9d..a306dfa89 100644
--- a/src/3rdparty/chromium/url/url_canon_internal.h
+++ b/src/3rdparty/chromium/url/url_canon_internal.h
@@ -305,9 +305,9 @@ inline bool Is8BitChar(base::char16 c) {
   return c <= 255;
 }
 
-template<typename CHAR>
+template<typename CHAR, typename DST>
 inline bool DecodeEscaped(const CHAR* spec, int* begin, int end,
-                          unsigned char* unescaped_value) {
+                          DST* unescaped_value) {
   if (*begin + 3 > end ||
       !Is8BitChar(spec[*begin + 1]) || !Is8BitChar(spec[*begin + 2])) {
     // Invalid escape sequence because there's not enough room, or the
-- 
2.26.2


From 4dd0559f3a71b9f4d341d706274d60a5196e4a98 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Sat, 23 Feb 2019 14:35:04 +0100
Subject: [PATCH 12/30] CRLSet: Fix LE dependency

---
 src/3rdparty/chromium/net/cert/crl_set.cc | 14 +++-----------
 1 file changed, 3 insertions(+), 11 deletions(-)

diff --git a/src/3rdparty/chromium/net/cert/crl_set.cc b/src/3rdparty/chromium/net/cert/crl_set.cc
index a782f22f2..db43f6b9d 100644
--- a/src/3rdparty/chromium/net/cert/crl_set.cc
+++ b/src/3rdparty/chromium/net/cert/crl_set.cc
@@ -8,6 +8,7 @@
 
 #include "base/base64.h"
 #include "base/json/json_reader.h"
+#include "base/sys_byteorder.h"
 #include "base/time/time.h"
 #include "base/trace_event/trace_event.h"
 #include "base/values.h"
@@ -57,9 +58,9 @@ base::DictionaryValue* ReadHeader(base::StringPiece* data) {
   uint16_t header_len;
   if (data->size() < sizeof(header_len))
     return nullptr;
-  // Assumes little-endian.
   memcpy(&header_len, data->data(), sizeof(header_len));
   data->remove_prefix(sizeof(header_len));
+  header_len = base::ByteSwapToLE16(header_len);
 
   if (data->size() < header_len)
     return nullptr;
@@ -92,9 +93,9 @@ bool ReadCRL(base::StringPiece* data,
   uint32_t num_serials;
   if (data->size() < sizeof(num_serials))
     return false;
-  // Assumes little endian.
   memcpy(&num_serials, data->data(), sizeof(num_serials));
   data->remove_prefix(sizeof(num_serials));
+  num_serials = base::ByteSwapToLE32(num_serials);
 
   if (num_serials > 32 * 1024 * 1024)  // Sanity check.
     return false;
@@ -205,15 +206,6 @@ CRLSet::~CRLSet() = default;
 // static
 bool CRLSet::Parse(base::StringPiece data, scoped_refptr<CRLSet>* out_crl_set) {
   TRACE_EVENT0(NetTracingCategory(), "CRLSet::Parse");
-// Other parts of Chrome assume that we're little endian, so we don't lose
-// anything by doing this.
-#if defined(__BYTE_ORDER)
-  // Linux check
-  static_assert(__BYTE_ORDER == __LITTLE_ENDIAN, "assumes little endian");
-#elif defined(__BIG_ENDIAN__)
-// Mac check
-#error assumes little endian
-#endif
 
   std::unique_ptr<base::DictionaryValue> header_dict(ReadHeader(&data));
   if (!header_dict.get())
-- 
2.26.2


From 3edb46d71058fbcff5d2c7256b7789442b8d0df6 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Sat, 23 Feb 2019 22:33:02 +0100
Subject: [PATCH 13/30] crc32c: Fix definition of BYTE_ORDER_BIG_ENDIAN

---
 src/3rdparty/chromium/third_party/crc32c/BUILD.gn | 5 +----
 1 file changed, 1 insertion(+), 4 deletions(-)

diff --git a/src/3rdparty/chromium/third_party/crc32c/BUILD.gn b/src/3rdparty/chromium/third_party/crc32c/BUILD.gn
index 5f1cba3cd..eac8d949a 100644
--- a/src/3rdparty/chromium/third_party/crc32c/BUILD.gn
+++ b/src/3rdparty/chromium/third_party/crc32c/BUILD.gn
@@ -15,13 +15,10 @@ config("crc32c_config") {
   ]
 
   defines = [
-    "BYTE_ORDER_BIG_ENDIAN=0",
+    "BYTE_ORDER_BIG_ENDIAN=__BYTE_ORDER__==__ORDER_BIG_ENDIAN__",
     "CRC32C_TESTS_BUILT_WITH_GLOG=0",
   ]
 
-  # If we ever support big-endian builds, add logic to conditionally enable
-  # BYTE_ORDER_BIG_ENDIAN.
-
   if (target_cpu == "x86" || target_cpu == "x64") {
     defines += [
       "HAVE_MM_PREFETCH=1",
-- 
2.26.2


From 7e0a5bde82af8e9c77f33227e55c637056d9345e Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Sat, 23 Feb 2019 22:41:44 +0100
Subject: [PATCH 14/30] leveldatabase: Fix endianness flag

---
 .../chromium/third_party/leveldatabase/port/port_chromium.h  | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/src/3rdparty/chromium/third_party/leveldatabase/port/port_chromium.h b/src/3rdparty/chromium/third_party/leveldatabase/port/port_chromium.h
index 6a9f74e4a..ec7eb94fd 100644
--- a/src/3rdparty/chromium/third_party/leveldatabase/port/port_chromium.h
+++ b/src/3rdparty/chromium/third_party/leveldatabase/port/port_chromium.h
@@ -20,8 +20,11 @@
 namespace leveldb {
 namespace port {
 
-// Chromium only supports little endian.
+#if ARCH_CPU_LITTLE_ENDIAN
 static const bool kLittleEndian = true;
+#else
+static const bool kLittleEndian = false;
+#endif
 
 class LOCKABLE Mutex {
  public:
-- 
2.26.2


From 72007147a451a36327c1b9aecfd1bca48dee52a7 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Wed, 6 Mar 2019 20:26:32 +0100
Subject: [PATCH 15/30] blink: handle pixel format selection independent of
 byteorder

---
 .../image-decoders/jpeg/jpeg_image_decoder.cc | 21 ++++++++++++-------
 .../image-decoders/webp/webp_image_decoder.cc | 12 +++++------
 2 files changed, 20 insertions(+), 13 deletions(-)

diff --git a/src/3rdparty/chromium/third_party/blink/renderer/platform/image-decoders/jpeg/jpeg_image_decoder.cc b/src/3rdparty/chromium/third_party/blink/renderer/platform/image-decoders/jpeg/jpeg_image_decoder.cc
index 3cafad17e..e1cf77db1 100644
--- a/src/3rdparty/chromium/third_party/blink/renderer/platform/image-decoders/jpeg/jpeg_image_decoder.cc
+++ b/src/3rdparty/chromium/third_party/blink/renderer/platform/image-decoders/jpeg/jpeg_image_decoder.cc
@@ -53,23 +53,30 @@ extern "C" {
 #include <setjmp.h>
 }
 
-#if defined(ARCH_CPU_BIG_ENDIAN)
-#error Blink assumes a little-endian target.
-#endif
-
 #if defined(JCS_ALPHA_EXTENSIONS)
 #define TURBO_JPEG_RGB_SWIZZLE
-#if SK_B32_SHIFT  // Output little-endian RGBA pixels (Android).
+#if SK_PMCOLOR_BYTE_ORDER(R, G, B, A)
 inline J_COLOR_SPACE rgbOutputColorSpace() {
   return JCS_EXT_RGBA;
 }
-#else  // Output little-endian BGRA pixels.
+#elif SK_PMCOLOR_BYTE_ORDER(B, G, R, A)
 inline J_COLOR_SPACE rgbOutputColorSpace() {
   return JCS_EXT_BGRA;
 }
+#elif SK_PMCOLOR_BYTE_ORDER(A, R, G, B)
+inline J_COLOR_SPACE rgbOutputColorSpace() {
+  return JCS_EXT_ARGB;
+}
+#elif SK_PMCOLOR_BYTE_ORDER(A, B, G, R)
+inline J_COLOR_SPACE rgbOutputColorSpace() {
+  return JCS_EXT_ABGR;
+}
+#else
+#error Component order not supported by libjpeg_turbo
 #endif
 inline bool turboSwizzled(J_COLOR_SPACE colorSpace) {
-  return colorSpace == JCS_EXT_RGBA || colorSpace == JCS_EXT_BGRA;
+  return colorSpace == JCS_EXT_RGBA || colorSpace == JCS_EXT_BGRA ||
+    colorSpace == JCS_EXT_ABGR || colorSpace == JCS_EXT_ARGB;
 }
 #else
 inline J_COLOR_SPACE rgbOutputColorSpace() {
diff --git a/src/3rdparty/chromium/third_party/blink/renderer/platform/image-decoders/webp/webp_image_decoder.cc b/src/3rdparty/chromium/third_party/blink/renderer/platform/image-decoders/webp/webp_image_decoder.cc
index a75f37382..2e9116e8c 100644
--- a/src/3rdparty/chromium/third_party/blink/renderer/platform/image-decoders/webp/webp_image_decoder.cc
+++ b/src/3rdparty/chromium/third_party/blink/renderer/platform/image-decoders/webp/webp_image_decoder.cc
@@ -37,10 +37,6 @@
 #include "third_party/skia/include/core/SkData.h"
 #include "third_party/skia/include/core/SkYUVAIndex.h"
 
-#if defined(ARCH_CPU_BIG_ENDIAN)
-#error Blink assumes a little-endian target.
-#endif
-
 namespace {
 
 // Returns two point ranges (<left, width> pairs) at row |canvasY| which belong
@@ -225,10 +221,14 @@ WEBP_CSP_MODE WEBPImageDecoder::RGBOutputMode() {
     return MODE_BGRA;
   }
   bool premultiply = (format_flags_ & ALPHA_FLAG) && premultiply_alpha_;
-#if SK_B32_SHIFT  // Output little-endian RGBA pixels (Android)
+#if SK_PMCOLOR_BYTE_ORDER(R, G, B, A) 
   return premultiply ? MODE_rgbA : MODE_RGBA;
-#else  // Output little-endian BGRA pixels.
+#elif SK_PMCOLOR_BYTE_ORDER(B, G, R, A) 
   return premultiply ? MODE_bgrA : MODE_BGRA;
+#elif SK_PMCOLOR_BYTE_ORDER(A, R, G, B)
+  return premultiply ? MODE_Argb : MODE_ARGB;
+#else
+#error Component order not supported by libwebp
 #endif
 }
 
-- 
2.26.2


From 940a89719a5d42b41ba8ec14e6e47d41e4a2e2b1 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Wed, 27 Mar 2019 21:32:08 +0100
Subject: [PATCH 16/30] blink: Fix BMP header parsing on big endian

---
 .../renderer/platform/image-decoders/bmp/bmp_image_reader.h  | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/src/3rdparty/chromium/third_party/blink/renderer/platform/image-decoders/bmp/bmp_image_reader.h b/src/3rdparty/chromium/third_party/blink/renderer/platform/image-decoders/bmp/bmp_image_reader.h
index 7ad7fc32a..ba33cc183 100644
--- a/src/3rdparty/chromium/third_party/blink/renderer/platform/image-decoders/bmp/bmp_image_reader.h
+++ b/src/3rdparty/chromium/third_party/blink/renderer/platform/image-decoders/bmp/bmp_image_reader.h
@@ -37,6 +37,7 @@
 #include "third_party/blink/renderer/platform/image-decoders/fast_shared_buffer_reader.h"
 #include "third_party/blink/renderer/platform/image-decoders/image_decoder.h"
 #include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
+#include "base/sys_byteorder.h"
 
 namespace blink {
 
@@ -49,11 +50,11 @@ class PLATFORM_EXPORT BMPImageReader final {
   // Read a value from |buffer|, converting to an int assuming little
   // endianness
   static inline uint16_t ReadUint16(const char* buffer) {
-    return *reinterpret_cast<const uint16_t*>(buffer);
+    return base::ByteSwapToLE16(*reinterpret_cast<const uint16_t*>(buffer));
   }
 
   static inline uint32_t ReadUint32(const char* buffer) {
-    return *reinterpret_cast<const uint32_t*>(buffer);
+    return base::ByteSwapToLE32(*reinterpret_cast<const uint32_t*>(buffer));
   }
 
   // |parent| is the decoder that owns us.
-- 
2.26.2


From eae3ea8952dafb94fdf4d3adcf536e9d96bdfbb8 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Wed, 27 Mar 2019 21:33:04 +0100
Subject: [PATCH 17/30] blink: Fix alpha check in GC tests

---
 .../blink/renderer/platform/graphics/graphics_context_test.cc | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/3rdparty/chromium/third_party/blink/renderer/platform/graphics/graphics_context_test.cc b/src/3rdparty/chromium/third_party/blink/renderer/platform/graphics/graphics_context_test.cc
index 5c364638b..9bc7029e8 100644
--- a/src/3rdparty/chromium/third_party/blink/renderer/platform/graphics/graphics_context_test.cc
+++ b/src/3rdparty/chromium/third_party/blink/renderer/platform/graphics/graphics_context_test.cc
@@ -54,7 +54,7 @@ namespace {
   {                                                              \
     for (int y = opaqueRect.Y(); y < opaqueRect.MaxY(); ++y)     \
       for (int x = opaqueRect.X(); x < opaqueRect.MaxX(); ++x) { \
-        int alpha = *bitmap.getAddr32(x, y) >> 24;               \
+        int alpha = SkGetPackedA32(*bitmap.getAddr32(x, y));	 \
         EXPECT_EQ(255, alpha);                                   \
       }                                                          \
   }
@@ -63,7 +63,7 @@ namespace {
   {                                                           \
     for (int y = 0; y < bitmap.height(); ++y)                 \
       for (int x = 0; x < bitmap.width(); ++x) {              \
-        int alpha = *bitmap.getAddr32(x, y) >> 24;            \
+        int alpha = SkGetPackedA32(*bitmap.getAddr32(x, y));  \
         bool opaque = opaqueRect.Contains(x, y);              \
         EXPECT_EQ(opaque, alpha == 255);                      \
       }                                                       \
-- 
2.26.2


From bb518a1a3cc7ce4ee031dd4d7b56cad0da8fc443 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Wed, 27 Mar 2019 21:34:12 +0100
Subject: [PATCH 18/30] blink: Fix typo in WebGL image conversion test

---
 .../platform/graphics/gpu/webgl_image_conversion_test.cc    | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/3rdparty/chromium/third_party/blink/renderer/platform/graphics/gpu/webgl_image_conversion_test.cc b/src/3rdparty/chromium/third_party/blink/renderer/platform/graphics/gpu/webgl_image_conversion_test.cc
index e31561585..7f3599ca0 100644
--- a/src/3rdparty/chromium/third_party/blink/renderer/platform/graphics/gpu/webgl_image_conversion_test.cc
+++ b/src/3rdparty/chromium/third_party/blink/renderer/platform/graphics/gpu/webgl_image_conversion_test.cc
@@ -76,9 +76,9 @@ TEST_F(WebGLImageConversionTest, convertBGRA8toRGBA8) {
                              0x34567888, 0x12345678, 0x34567888,
                              0x12345678, 0x34567888, 0x12345678};
 #if defined(ARCH_CPU_BIG_ENDIAN)
-  uint32_t expectedData[9] = {0x56341278, 0x78563488, 0x56341278,
-                              0x78563488, 0x56341278, 0x78563488,
-                              0x56341278, 0x78563488, 0x56341278};
+  uint32_t expected_data[9] = {0x56341278, 0x78563488, 0x56341278,
+			       0x78563488, 0x56341278, 0x78563488,
+			       0x56341278, 0x78563488, 0x56341278};
 #else
   uint32_t expected_data[9] = {0x12785634, 0x34887856, 0x12785634,
                                0x34887856, 0x12785634, 0x34887856,
-- 
2.26.2


From 4478226bc64e71d473690b0a1be410ecdea7b0fc Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Sat, 6 Apr 2019 15:43:20 +0200
Subject: [PATCH 19/30] blink: Fix bizarre endianness dependency in TensorFlow
 output

---
 .../graphics/darkmode/darkmode_classifier.cc  | 53 ++++++++-----------
 1 file changed, 21 insertions(+), 32 deletions(-)

diff --git a/src/3rdparty/chromium/third_party/blink/renderer/platform/graphics/darkmode/darkmode_classifier.cc b/src/3rdparty/chromium/third_party/blink/renderer/platform/graphics/darkmode/darkmode_classifier.cc
index 858e6a14d..b184f4f91 100644
--- a/src/3rdparty/chromium/third_party/blink/renderer/platform/graphics/darkmode/darkmode_classifier.cc
+++ b/src/3rdparty/chromium/third_party/blink/renderer/platform/graphics/darkmode/darkmode_classifier.cc
@@ -1067,58 +1067,47 @@ void DequantizeMinFirst(const int32_t rank,
 
 // -----------------------------------------------------------------------------
 // CONSTANTS
-// Note that for now, endianness of the target machine needs to match that of
-// the one training was performed on.
 // -----------------------------------------------------------------------------
 const int32_t dnn_hiddenlayer_0_weights_part_0_shape[2] = {4, 10};
 const union {
-  uint8_t bytes[160];
   float values[40];
 } dnn_hiddenlayer_0_weights_part_0 = {{
-    0xbc, 0x22, 0x0a, 0xbf, 0xb4, 0x46, 0x8c, 0x3f, 0xba, 0x31, 0x34, 0xbe,
-    0x4c, 0x65, 0xdb, 0xbe, 0xf0, 0x54, 0x5e, 0xbe, 0xc1, 0x5d, 0xb3, 0x3f,
-    0xf4, 0xe6, 0x15, 0xbf, 0x05, 0xc6, 0x34, 0xbf, 0xc0, 0x37, 0x7e, 0xbd,
-    0x6c, 0x35, 0x0b, 0xbf, 0xca, 0x53, 0x26, 0xbf, 0x58, 0xb4, 0x87, 0x3f,
-    0x37, 0xee, 0x39, 0xbf, 0xda, 0xfa, 0xf9, 0xbe, 0x97, 0xc1, 0x06, 0xbf,
-    0xf9, 0x4e, 0x81, 0x3f, 0xb2, 0x44, 0x85, 0xbf, 0x7f, 0x98, 0x7c, 0x3d,
-    0x15, 0x26, 0xbc, 0xbe, 0x5c, 0x48, 0x05, 0x3f, 0xc8, 0xaa, 0xa1, 0xbd,
-    0x35, 0xb3, 0x43, 0xbe, 0xeb, 0x46, 0x91, 0x3f, 0x80, 0x71, 0xe3, 0x3c,
-    0xd1, 0x98, 0x79, 0x3f, 0x3c, 0xd0, 0x0d, 0xbf, 0x1e, 0x02, 0xd3, 0x3e,
-    0x5d, 0x4b, 0xa2, 0xbf, 0x68, 0xac, 0xaa, 0xbd, 0xf8, 0xe1, 0x75, 0x3e,
-    0x4a, 0x9c, 0x27, 0xbe, 0xf8, 0xae, 0xb2, 0xbe, 0x7f, 0x9d, 0x91, 0x3f,
-    0x1e, 0x8b, 0xa8, 0xbe, 0x35, 0x7e, 0xb2, 0x3f, 0xbe, 0x8c, 0xd3, 0xbe,
-    0xf9, 0xcd, 0xb5, 0x3f, 0xa1, 0x50, 0xaa, 0x3f, 0xe4, 0x6d, 0xdd, 0xbe,
-    0x0d, 0xce, 0xd3, 0xbe,
+     -0.539592504501343,   1.09590768814087, -0.175970941781998, -0.428507208824158,
+     -0.217120885848999,   1.40129864215851,   -0.5855553150177, -0.706146538257599,
+    -0.0620648860931396, -0.543783903121948, -0.649716019630432,   1.06019115447998,
+     -0.726291120052338, -0.488241970539093, -0.526391446590424,   1.01022255420685,
+      -1.04115891456604, 0.0616688691079617, -0.367478042840958,  0.520635366439819,
+    -0.0789390206336975,  -0.19111330807209,   1.13497674465179, 0.0277640819549561,
+      0.974988043308258, -0.553958654403687,  0.412125527858734,   -1.2679249048233,
+    -0.0833366513252258,  0.240119814872742, -0.163682132959366,  -0.34899115562439,
+        1.1376188993454, -0.329186379909515,    1.3944765329361, -0.413183152675629,
+       1.42034828662872,   1.33058559894562, -0.432479023933411, -0.413681417703629
 }};
 const int32_t dnn_hiddenlayer_0_biases_part_0_shape[1] = {10};
 const union {
-  uint8_t bytes[40];
   float values[10];
 } dnn_hiddenlayer_0_biases_part_0 = {{
-    0x00, 0x00, 0x00, 0x00, 0xbf, 0x6a, 0x53, 0x3e, 0xd3, 0xc1,
-    0xd0, 0x3e, 0x00, 0x00, 0x00, 0x00, 0xb6, 0xd8, 0xc0, 0x3e,
-    0xca, 0xe7, 0x35, 0x3e, 0x23, 0xa5, 0x44, 0x3f, 0x61, 0xfd,
-    0xd2, 0x3e, 0x00, 0x00, 0x00, 0x00, 0xb6, 0xe0, 0x43, 0x3c,
+                    0.0,  0.206461891531944,
+      0.407728761434555,                0.0,
+      0.376653373241425,  0.177642017602921,
+       0.76814478635788,  0.412089377641678,
+                    0.0, 0.0119554307311773
 }};
 const int32_t dnn_logits_biases_part_0_shape[1] = {1};
 const union {
-  uint8_t bytes[4];
   float values[1];
 } dnn_logits_biases_part_0 = {{
-    0x75,
-    0xca,
-    0xd7,
-    0xbe,
+    -0.421466499567032
 }};
 const int32_t dnn_logits_weights_part_0_shape[2] = {10, 1};
 const union {
-  uint8_t bytes[40];
   float values[10];
 } dnn_logits_weights_part_0 = {{
-    0x13, 0x12, 0x39, 0x3f, 0xf3, 0xa5, 0xc2, 0xbf, 0x81, 0x7f,
-    0xbe, 0x3f, 0xf8, 0x17, 0x26, 0x3e, 0xa4, 0x19, 0xa6, 0x3f,
-    0xf0, 0xc9, 0xb7, 0xbf, 0x6a, 0x99, 0xd2, 0x3f, 0x8a, 0x7d,
-    0xe9, 0x3f, 0x83, 0x9a, 0x3a, 0xbf, 0xf1, 0x6c, 0x08, 0x3e,
+      0.722932040691376,  -1.52068936824799,
+       1.48826611042023,  0.162200808525085,
+       1.29765748977661,  -1.43585014343262,
+       1.64530682563782,   1.82414364814758,
+     -0.728920161724091,  0.133228078484535
 }};
 
 }  // anonymous namespace
-- 
2.26.2


From 945d9f1150c67c87eb4025a65c406b42ed704297 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Sat, 6 Apr 2019 15:49:03 +0200
Subject: [PATCH 20/30] aura: Fix UTF16 BOM

---
 .../ui/base/dragdrop/os_exchange_data_provider_aurax11.cc   | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/src/3rdparty/chromium/ui/base/dragdrop/os_exchange_data_provider_aurax11.cc b/src/3rdparty/chromium/ui/base/dragdrop/os_exchange_data_provider_aurax11.cc
index c92301055..87d4dde2b 100644
--- a/src/3rdparty/chromium/ui/base/dragdrop/os_exchange_data_provider_aurax11.cc
+++ b/src/3rdparty/chromium/ui/base/dragdrop/os_exchange_data_provider_aurax11.cc
@@ -11,6 +11,7 @@
 #include "base/strings/string_split.h"
 #include "base/strings/string_util.h"
 #include "base/strings/utf_string_conversions.h"
+#include "base/sys_byteorder.h"
 #include "net/base/filename_util.h"
 #include "ui/base/clipboard/clipboard_constants.h"
 #include "ui/base/clipboard/clipboard_format_type.h"
@@ -432,8 +433,13 @@ void OSExchangeDataProviderAuraX11::SetHtml(const base::string16& html,
   std::vector<unsigned char> bytes;
   // Manually jam a UTF16 BOM into bytes because otherwise, other programs will
   // assume UTF-8.
+#if defined(ARCH_CPU_LITTLE_ENDIAN)
   bytes.push_back(0xFF);
   bytes.push_back(0xFE);
+#else
+  bytes.push_back(0xFE);
+  bytes.push_back(0xFF);
+#endif
   ui::AddString16ToVector(html, &bytes);
   scoped_refptr<base::RefCountedMemory> mem(
       base::RefCountedBytes::TakeVector(&bytes));
-- 
2.26.2


From fb95d6291fbd0f7c846df8f13ea0dca853020b97 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Sat, 6 Apr 2019 23:35:33 +0200
Subject: [PATCH 21/30] gfx: Use correct function to create a SkPMColor rather
 than a SkColor

---
 src/3rdparty/chromium/ui/gfx/skbitmap_operations_unittest.cc | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/3rdparty/chromium/ui/gfx/skbitmap_operations_unittest.cc b/src/3rdparty/chromium/ui/gfx/skbitmap_operations_unittest.cc
index 65f684388..8adb30217 100644
--- a/src/3rdparty/chromium/ui/gfx/skbitmap_operations_unittest.cc
+++ b/src/3rdparty/chromium/ui/gfx/skbitmap_operations_unittest.cc
@@ -238,7 +238,7 @@ TEST(SkBitmapOperationsTest, CreateHSLShiftedBitmapHueOnly) {
 
   for (int y = 0, i = 0; y < src_h; y++) {
     for (int x = 0; x < src_w; x++) {
-      *src.getAddr32(x, y) = SkColorSetARGB(255, 0, 0, i % 255);
+      *src.getAddr32(x, y) = SkPackARGB32(255, 0, 0, i % 255);
       i++;
     }
   }
-- 
2.26.2


From de7c99889bde35505389156b7cd198c42e23629b Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Sun, 7 Apr 2019 11:54:18 +0200
Subject: [PATCH 22/30] skia: Fix testcases to use SkPMColor rather than
 SkColor for internal access

---
 .../chromium/skia/ext/image_operations_unittest.cc   | 12 +++++++-----
 1 file changed, 7 insertions(+), 5 deletions(-)

diff --git a/src/3rdparty/chromium/skia/ext/image_operations_unittest.cc b/src/3rdparty/chromium/skia/ext/image_operations_unittest.cc
index 897095517..253a55140 100644
--- a/src/3rdparty/chromium/skia/ext/image_operations_unittest.cc
+++ b/src/3rdparty/chromium/skia/ext/image_operations_unittest.cc
@@ -18,9 +18,11 @@
 #include "skia/ext/image_operations.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "third_party/skia/include/core/SkBitmap.h"
+#include "third_party/skia/include/core/SkColorPriv.h"
 #include "third_party/skia/include/core/SkColorSpace.h"
 #include "third_party/skia/include/core/SkImageInfo.h"
 #include "third_party/skia/include/core/SkRect.h"
+#include "third_party/skia/include/core/SkUnPreMultiply.h"
 #include "ui/gfx/codec/png_codec.h"
 #include "ui/gfx/geometry/size.h"
 
@@ -151,7 +153,7 @@ void DrawCheckerToBitmap(int w, int h,
 
       bool use_color2 = (x_bit != y_bit);  // xor
 
-      *bmp->getAddr32(x, y) = (use_color2 ? color2 : color1);
+      *bmp->getAddr32(x, y) = SkPreMultiplyColor(use_color2 ? color2 : color1);
     }
   }
 }
@@ -273,7 +275,7 @@ void CheckResizeMethodShouldAverageGrid(
         std::max(tested_pixel.max_color_distance,
                  tested_method.max_color_distance_override);
 
-    const SkColor actual_color = *dest.getAddr32(x, y);
+    const SkColor actual_color = SkUnPreMultiply::PMColorToColor(*dest.getAddr32(x, y));
 
     // Check that the pixels away from the border region are very close
     // to the expected average color
@@ -528,7 +530,7 @@ TEST(ImageOperations, ScaleUp) {
   for (int src_y = 0; src_y < src_h; ++src_y) {
     for (int src_x = 0; src_x < src_w; ++src_x) {
       *src.getAddr32(src_x, src_y) =
-          SkColorSetARGB(255, 10 + src_x * 100, 10 + src_y * 100, 0);
+          SkPackARGB32(255, 10 + src_x * 100, 10 + src_y * 100, 0);
     }
   }
 
@@ -552,7 +554,7 @@ TEST(ImageOperations, ScaleUp) {
               lanczos3(src_x + 0.5 - dst_x_in_src) *
               lanczos3(src_y + 0.5 - dst_y_in_src);
           sum += coeff;
-          SkColor tmp = *src.getAddr32(src_x, src_y);
+          SkColor tmp = SkUnPreMultiply::PMColorToColor(*src.getAddr32(src_x, src_y));
           a += coeff * SkColorGetA(tmp);
           r += coeff * SkColorGetR(tmp);
           g += coeff * SkColorGetG(tmp);
@@ -571,7 +573,7 @@ TEST(ImageOperations, ScaleUp) {
       if (r > 255.0f) r = 255.0f;
       if (g > 255.0f) g = 255.0f;
       if (b > 255.0f) b = 255.0f;
-      SkColor dst_color = *dst.getAddr32(dst_x, dst_y);
+      SkColor dst_color = SkUnPreMultiply::PMColorToColor(*dst.getAddr32(dst_x, dst_y));
       EXPECT_LE(fabs(SkColorGetA(dst_color) - a), 1.5f);
       EXPECT_LE(fabs(SkColorGetR(dst_color) - r), 1.5f);
       EXPECT_LE(fabs(SkColorGetG(dst_color) - g), 1.5f);
-- 
2.26.2


From 5812a7e838b983af6215f7b5e4a6ee5763e0dde1 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Sun, 7 Apr 2019 14:19:52 +0200
Subject: [PATCH 23/30] gfx: Convert PMColor to Color before passing it to
 BGRAGrayEqualsA8Gray

---
 src/3rdparty/chromium/ui/gfx/codec/png_codec_unittest.cc | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/3rdparty/chromium/ui/gfx/codec/png_codec_unittest.cc b/src/3rdparty/chromium/ui/gfx/codec/png_codec_unittest.cc
index 260f7c976..b949b3e59 100644
--- a/src/3rdparty/chromium/ui/gfx/codec/png_codec_unittest.cc
+++ b/src/3rdparty/chromium/ui/gfx/codec/png_codec_unittest.cc
@@ -853,7 +853,7 @@ TEST(PNGCodec, EncodeA8SkBitmap) {
     for (int y = 0; y < h; y++) {
       uint8_t original_pixel = *original_bitmap.getAddr8(x, y);
       uint32_t decoded_pixel = *decoded_bitmap.getAddr32(x, y);
-      EXPECT_TRUE(BGRAGrayEqualsA8Gray(decoded_pixel, original_pixel));
+      EXPECT_TRUE(BGRAGrayEqualsA8Gray(SkUnPreMultiply::PMColorToColor(decoded_pixel), original_pixel));
     }
   }
 }
-- 
2.26.2


From 3aad4bf1f14a64855ac6b36fbdf0cde45965cd9b Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Sun, 7 Apr 2019 16:51:54 +0200
Subject: [PATCH 24/30] gfx: select JPEG color space in an endian-neutral
 manner

---
 src/3rdparty/chromium/ui/gfx/codec/jpeg_codec.cc | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/src/3rdparty/chromium/ui/gfx/codec/jpeg_codec.cc b/src/3rdparty/chromium/ui/gfx/codec/jpeg_codec.cc
index fe91867f3..f257ca327 100644
--- a/src/3rdparty/chromium/ui/gfx/codec/jpeg_codec.cc
+++ b/src/3rdparty/chromium/ui/gfx/codec/jpeg_codec.cc
@@ -211,12 +211,13 @@ bool JPEGCodec::Decode(const unsigned char* input, size_t input_size,
       // Same as JPEGCodec::Encode(), libjpeg-turbo supports all input formats
       // used by Chromium (i.e. RGBA and BGRA) and we just map the input
       // parameters to a colorspace.
+
       if (format == FORMAT_RGBA ||
-          (format == FORMAT_SkBitmap && SK_R32_SHIFT == 0)) {
+          (format == FORMAT_SkBitmap && SK_PMCOLOR_BYTE_ORDER(R, G, B, A))) {
         cinfo->out_color_space = JCS_EXT_RGBX;
         cinfo->output_components = 4;
       } else if (format == FORMAT_BGRA ||
-                 (format == FORMAT_SkBitmap && SK_B32_SHIFT == 0)) {
+                 (format == FORMAT_SkBitmap && SK_PMCOLOR_BYTE_ORDER(B, G, R, A))) {
         cinfo->out_color_space = JCS_EXT_BGRX;
         cinfo->output_components = 4;
       } else {
-- 
2.26.2


From 8a8c727561c9f76399dc84f0bb6fabb00e000765 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Sun, 7 Apr 2019 21:22:12 +0200
Subject: [PATCH 25/30] gfx: Fix color analysis on big endian

This also adds an ARGB decode mode to the PNG codec since
CalculateKMeanColorOfBuffer needs the pixels to be in SkColor (which
is ARGB on big endian) order.
---
 .../chromium/ui/gfx/codec/png_codec.cc        | 10 ++++++
 .../chromium/ui/gfx/codec/png_codec.h         |  4 +++
 .../chromium/ui/gfx/color_analysis.cc         | 31 +++++++++++++++++--
 3 files changed, 42 insertions(+), 3 deletions(-)

diff --git a/src/3rdparty/chromium/ui/gfx/codec/png_codec.cc b/src/3rdparty/chromium/ui/gfx/codec/png_codec.cc
index f2176e920..d44b769d0 100644
--- a/src/3rdparty/chromium/ui/gfx/codec/png_codec.cc
+++ b/src/3rdparty/chromium/ui/gfx/codec/png_codec.cc
@@ -169,6 +169,10 @@ void DecodeInfoCallback(png_struct* png_ptr, png_info* info_ptr) {
         png_set_bgr(png_ptr);
         png_set_add_alpha(png_ptr, 0xFF, PNG_FILLER_AFTER);
         break;
+      case PNGCodec::FORMAT_ARGB:
+        state->output_channels = 4;
+        png_set_add_alpha(png_ptr, 0xFF, PNG_FILLER_BEFORE);
+        break;
       case PNGCodec::FORMAT_SkBitmap:
         state->output_channels = 4;
         png_set_add_alpha(png_ptr, 0xFF, PNG_FILLER_AFTER);
@@ -183,6 +187,10 @@ void DecodeInfoCallback(png_struct* png_ptr, png_info* info_ptr) {
         state->output_channels = 4;
         png_set_bgr(png_ptr);
         break;
+      case PNGCodec::FORMAT_ARGB:
+        state->output_channels = 4;
+	png_set_swap_alpha(png_ptr);
+        break;
       case PNGCodec::FORMAT_SkBitmap:
         state->output_channels = 4;
         break;
@@ -475,6 +483,8 @@ bool PNGCodec::Encode(const unsigned char* input,
     case FORMAT_BGRA:
       colorType = kBGRA_8888_SkColorType;
       break;
+    case FORMAT_ARGB:
+      return false;
     case FORMAT_SkBitmap:
       colorType = kN32_SkColorType;
       break;
diff --git a/src/3rdparty/chromium/ui/gfx/codec/png_codec.h b/src/3rdparty/chromium/ui/gfx/codec/png_codec.h
index dc55eacff..bb9c4f608 100644
--- a/src/3rdparty/chromium/ui/gfx/codec/png_codec.h
+++ b/src/3rdparty/chromium/ui/gfx/codec/png_codec.h
@@ -37,6 +37,10 @@ class CODEC_EXPORT PNGCodec {
     // This is the default Windows DIB order.
     FORMAT_BGRA,
 
+    // 4 bytes per pixel, in ARGB order in memory regardless of endianness.
+    // Only supported for decoding
+    FORMAT_ARGB,
+
     // SkBitmap format. For Encode() kN32_SkColorType (4 bytes per pixel) and
     // kAlpha_8_SkColorType (1 byte per pixel) formats are supported.
     // kAlpha_8_SkColorType gets encoded into a grayscale PNG treating alpha as
diff --git a/src/3rdparty/chromium/ui/gfx/color_analysis.cc b/src/3rdparty/chromium/ui/gfx/color_analysis.cc
index ed3a82e9b..39f27b3f2 100644
--- a/src/3rdparty/chromium/ui/gfx/color_analysis.cc
+++ b/src/3rdparty/chromium/ui/gfx/color_analysis.cc
@@ -19,6 +19,7 @@
 #include "base/callback.h"
 #include "base/logging.h"
 #include "base/numerics/ranges.h"
+#include "base/sys_byteorder.h"
 #include "third_party/skia/include/core/SkBitmap.h"
 #include "third_party/skia/include/core/SkUnPreMultiply.h"
 #include "ui/gfx/codec/png_codec.h"
@@ -438,10 +439,17 @@ SkColor FindClosestColor(const uint8_t* image,
   SkColor best_color = color;
   const uint8_t* byte = image;
   for (int i = 0; i < width * height; ++i) {
+#if defined(ARCH_CPU_LITTLE_ENDIAN)
     uint8_t b = *(byte++);
     uint8_t g = *(byte++);
     uint8_t r = *(byte++);
     uint8_t a = *(byte++);
+#else
+    uint8_t a = *(byte++);
+    uint8_t r = *(byte++);
+    uint8_t g = *(byte++);
+    uint8_t b = *(byte++);
+#endif
     // Ignore fully transparent pixels.
     if (a == 0)
       continue;
@@ -459,7 +467,6 @@ SkColor FindClosestColor(const uint8_t* image,
 
 // For a 16x16 icon on an Intel Core i5 this function takes approximately
 // 0.5 ms to run.
-// TODO(port): This code assumes the CPU architecture is little-endian.
 SkColor CalculateKMeanColorOfBuffer(uint8_t* decoded_data,
                                     int img_width,
                                     int img_height,
@@ -482,10 +489,17 @@ SkColor CalculateKMeanColorOfBuffer(uint8_t* decoded_data,
         int pixel_pos = sampler->GetSample(img_width, img_height) %
             (img_width * img_height);
 
+#if defined(ARCH_CPU_LITTLE_ENDIAN)
         uint8_t b = decoded_data[pixel_pos * 4];
         uint8_t g = decoded_data[pixel_pos * 4 + 1];
         uint8_t r = decoded_data[pixel_pos * 4 + 2];
         uint8_t a = decoded_data[pixel_pos * 4 + 3];
+#else
+        uint8_t a = decoded_data[pixel_pos * 4];
+        uint8_t r = decoded_data[pixel_pos * 4 + 1];
+        uint8_t g = decoded_data[pixel_pos * 4 + 2];
+        uint8_t b = decoded_data[pixel_pos * 4 + 3];
+#endif
         // Skip fully transparent pixels as they usually contain black in their
         // RGB channels but do not contribute to the visual image.
         if (a == 0)
@@ -534,10 +548,17 @@ SkColor CalculateKMeanColorOfBuffer(uint8_t* decoded_data,
       uint8_t* pixel = decoded_data;
       uint8_t* decoded_data_end = decoded_data + (img_width * img_height * 4);
       while (pixel < decoded_data_end) {
+#if defined(ARCH_CPU_LITTLE_ENDIAN)
         uint8_t b = *(pixel++);
         uint8_t g = *(pixel++);
         uint8_t r = *(pixel++);
         uint8_t a = *(pixel++);
+#else
+        uint8_t a = *(pixel++);
+        uint8_t r = *(pixel++);
+        uint8_t g = *(pixel++);
+        uint8_t b = *(pixel++);
+#endif
         // Skip transparent pixels, see above.
         if (a == 0)
           continue;
@@ -615,8 +636,12 @@ SkColor CalculateKMeanColorOfPNG(scoped_refptr<base::RefCountedMemory> png,
 
   if (png.get() && png->size() &&
       gfx::PNGCodec::Decode(png->front(), png->size(),
-                            gfx::PNGCodec::FORMAT_BGRA, &decoded_data,
-                            &img_width, &img_height)) {
+#if defined(ARCH_CPU_LITTLE_ENDIAN)
+                            gfx::PNGCodec::FORMAT_BGRA,
+#else
+                            gfx::PNGCodec::FORMAT_ARGB,
+#endif
+			    &decoded_data, &img_width, &img_height)) {
     return CalculateKMeanColorOfBuffer(&decoded_data[0], img_width, img_height,
                                        lower_bound, upper_bound, sampler, true);
   }
-- 
2.26.2


From 2096c527c989d814e53b8008750704d5e6f3538a Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Sun, 28 Apr 2019 15:22:43 +0200
Subject: [PATCH 26/30] sandbox: Fix SECCOMP_*_[LM]SB_IDX for ppc64

---
 .../chromium/sandbox/linux/bpf_dsl/seccomp_macros.h   | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/src/3rdparty/chromium/sandbox/linux/bpf_dsl/seccomp_macros.h b/src/3rdparty/chromium/sandbox/linux/bpf_dsl/seccomp_macros.h
index a6aec544e..2ab38b822 100644
--- a/src/3rdparty/chromium/sandbox/linux/bpf_dsl/seccomp_macros.h
+++ b/src/3rdparty/chromium/sandbox/linux/bpf_dsl/seccomp_macros.h
@@ -375,6 +375,7 @@ typedef struct pt_regs regs_struct;
 
 #define SECCOMP_NR_IDX (offsetof(struct arch_seccomp_data, nr))
 #define SECCOMP_ARCH_IDX (offsetof(struct arch_seccomp_data, arch))
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
 #define SECCOMP_IP_MSB_IDX \
   (offsetof(struct arch_seccomp_data, instruction_pointer) + 4)
 #define SECCOMP_IP_LSB_IDX \
@@ -383,6 +384,16 @@ typedef struct pt_regs regs_struct;
   (offsetof(struct arch_seccomp_data, args) + 8 * (nr) + 4)
 #define SECCOMP_ARG_LSB_IDX(nr) \
   (offsetof(struct arch_seccomp_data, args) + 8 * (nr) + 0)
+#else
+#define SECCOMP_IP_MSB_IDX \
+  (offsetof(struct arch_seccomp_data, instruction_pointer) + 0)
+#define SECCOMP_IP_LSB_IDX \
+  (offsetof(struct arch_seccomp_data, instruction_pointer) + 4)
+#define SECCOMP_ARG_MSB_IDX(nr) \
+  (offsetof(struct arch_seccomp_data, args) + 8 * (nr) + 0)
+#define SECCOMP_ARG_LSB_IDX(nr) \
+  (offsetof(struct arch_seccomp_data, args) + 8 * (nr) + 4)
+#endif
 
 #define SECCOMP_PT_RESULT(_regs) (_regs).gpr[3]
 #define SECCOMP_PT_SYSCALL(_regs) (_regs).gpr[0]
-- 
2.26.2


From 032199e48aa56a8fec27b3eeae85241e8d55aa90 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Sat, 18 May 2019 11:47:03 +0200
Subject: [PATCH 27/30] media/renderers: Fix component order test to check
 bytes instead of shifts

---
 .../chromium/media/renderers/paint_canvas_video_renderer.cc | 6 ++----
 1 file changed, 2 insertions(+), 4 deletions(-)

diff --git a/src/3rdparty/chromium/media/renderers/paint_canvas_video_renderer.cc b/src/3rdparty/chromium/media/renderers/paint_canvas_video_renderer.cc
index 9c62c6e4a..a638b149d 100644
--- a/src/3rdparty/chromium/media/renderers/paint_canvas_video_renderer.cc
+++ b/src/3rdparty/chromium/media/renderers/paint_canvas_video_renderer.cc
@@ -43,8 +43,7 @@
 // Skia internal format depends on a platform. On Android it is ABGR, on others
 // it is ARGB. Commented out lines below don't exist in libyuv yet and are
 // shown here to indicate where ideal conversions are currently missing.
-#if SK_B32_SHIFT == 0 && SK_G32_SHIFT == 8 && SK_R32_SHIFT == 16 && \
-    SK_A32_SHIFT == 24
+#if SK_PMCOLOR_BYTE_ORDER(B,G,R,A)
 #define LIBYUV_I420_TO_ARGB libyuv::I420ToARGB
 #define LIBYUV_I422_TO_ARGB libyuv::I422ToARGB
 #define LIBYUV_I444_TO_ARGB libyuv::I444ToARGB
@@ -80,8 +79,7 @@
 // #define LIBYUV_U410_TO_ARGB libyuv::U410ToARGB
 
 #define LIBYUV_NV12_TO_ARGB libyuv::NV12ToARGB
-#elif SK_R32_SHIFT == 0 && SK_G32_SHIFT == 8 && SK_B32_SHIFT == 16 && \
-    SK_A32_SHIFT == 24
+#elif SK_PMCOLOR_BYTE_ORDER(R,G,B,A)
 #define LIBYUV_I420_TO_ARGB libyuv::I420ToABGR
 #define LIBYUV_I422_TO_ARGB libyuv::I422ToABGR
 #define LIBYUV_I444_TO_ARGB libyuv::I444ToABGR
-- 
2.26.2


From ccbf258a8cbbfa72143446cc9eb1c2193fd4c0f5 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Sat, 18 May 2019 12:07:30 +0200
Subject: [PATCH 28/30] media/ffmpeg: Remove #error on endianness

---
 src/3rdparty/chromium/media/ffmpeg/ffmpeg_common.cc | 4 ----
 1 file changed, 4 deletions(-)

diff --git a/src/3rdparty/chromium/media/ffmpeg/ffmpeg_common.cc b/src/3rdparty/chromium/media/ffmpeg/ffmpeg_common.cc
index ddce1389f..35671fbd3 100644
--- a/src/3rdparty/chromium/media/ffmpeg/ffmpeg_common.cc
+++ b/src/3rdparty/chromium/media/ffmpeg/ffmpeg_common.cc
@@ -733,10 +733,6 @@ ChannelLayout ChannelLayoutToChromeChannelLayout(int64_t layout, int channels) {
   }
 }
 
-#if !defined(ARCH_CPU_LITTLE_ENDIAN)
-#error The code below assumes little-endianness.
-#endif
-
 VideoPixelFormat AVPixelFormatToVideoPixelFormat(AVPixelFormat pixel_format) {
   // The YUVJ alternatives are FFmpeg's (deprecated, but still in use) way to
   // specify a pixel format and full range color combination.
-- 
2.26.2


From fdba06d37924015bab81cba456569e398631d4d8 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Sat, 18 May 2019 12:07:49 +0200
Subject: [PATCH 29/30] media/formats/mp4: Fix endian dependent code in
 OpusSpecificBox::Parse

---
 .../media/formats/mp4/box_definitions.cc        | 17 ++++++++---------
 1 file changed, 8 insertions(+), 9 deletions(-)

diff --git a/src/3rdparty/chromium/media/formats/mp4/box_definitions.cc b/src/3rdparty/chromium/media/formats/mp4/box_definitions.cc
index 7352d9c45..c867b0429 100644
--- a/src/3rdparty/chromium/media/formats/mp4/box_definitions.cc
+++ b/src/3rdparty/chromium/media/formats/mp4/box_definitions.cc
@@ -1114,15 +1114,14 @@ bool OpusSpecificBox::Parse(BoxReader* reader) {
   RCHECK(reader->Read4(&sample_rate));
   RCHECK(reader->Read2s(&gain_db));
 
-#if !defined(ARCH_CPU_LITTLE_ENDIAN)
-#error The code below assumes little-endianness.
-#endif
-
-  memcpy(&extradata[OPUS_EXTRADATA_SKIP_SAMPLES_OFFSET], &codec_delay_in_frames,
-         sizeof(codec_delay_in_frames));
-  memcpy(&extradata[OPUS_EXTRADATA_SAMPLE_RATE_OFFSET], &sample_rate,
-         sizeof(sample_rate));
-  memcpy(&extradata[OPUS_EXTRADATA_GAIN_OFFSET], &gain_db, sizeof(gain_db));
+  extradata[OPUS_EXTRADATA_SKIP_SAMPLES_OFFSET] = (codec_delay_in_frames >> 0) & 0xff;
+  extradata[OPUS_EXTRADATA_SKIP_SAMPLES_OFFSET+1] = (codec_delay_in_frames >> 8) & 0xff;
+  extradata[OPUS_EXTRADATA_SAMPLE_RATE_OFFSET] = (sample_rate >> 0) & 0xff;
+  extradata[OPUS_EXTRADATA_SAMPLE_RATE_OFFSET+1] = (sample_rate >> 8) & 0xff;
+  extradata[OPUS_EXTRADATA_SAMPLE_RATE_OFFSET+2] = (sample_rate >> 16) & 0xff;
+  extradata[OPUS_EXTRADATA_SAMPLE_RATE_OFFSET+3] = (sample_rate >> 24) & 0xff;
+  extradata[OPUS_EXTRADATA_GAIN_OFFSET] = (gain_db >> 0) & 0xff;
+  extradata[OPUS_EXTRADATA_GAIN_OFFSET+1] = (gain_db >> 8) & 0xff;
 
   channel_count = extradata[OPUS_EXTRADATA_CHANNELS_OFFSET];
 
-- 
2.26.2


From ced0029a2e3500619596aa08fefcdddfea1d9c14 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Sat, 18 May 2019 12:25:41 +0200
Subject: [PATCH 30/30] skia: Select RGBA component order on big endian

---
 .../chromium/skia/config/SkUserConfig.h        | 18 +++++++-----------
 1 file changed, 7 insertions(+), 11 deletions(-)

diff --git a/src/3rdparty/chromium/skia/config/SkUserConfig.h b/src/3rdparty/chromium/skia/config/SkUserConfig.h
index 1cc2cdaee..c23bd4e1a 100644
--- a/src/3rdparty/chromium/skia/config/SkUserConfig.h
+++ b/src/3rdparty/chromium/skia/config/SkUserConfig.h
@@ -156,11 +156,18 @@ SK_API void SkDebugf_FileLine(const char* file,
                               ...);
 
 #if !defined(ANDROID)   // On Android, we use the skia default settings.
+#if defined(SK_CPU_BENDIAN)
+#define SK_A32_SHIFT    0
+#define SK_R32_SHIFT    24 
+#define SK_G32_SHIFT    16
+#define SK_B32_SHIFT    8
+#else
 #define SK_A32_SHIFT    24
 #define SK_R32_SHIFT    16
 #define SK_G32_SHIFT    8
 #define SK_B32_SHIFT    0
 #endif
+#endif
 
 #if defined(SK_BUILD_FOR_MAC)
 
@@ -174,17 +181,6 @@ SK_API void SkDebugf_FileLine(const char* file,
 // we should revisit this choice...
 #define SK_USE_FREETYPE_EMBOLDEN
 
-#if defined(SK_BUILD_FOR_UNIX) && defined(SK_CPU_BENDIAN)
-// Above we set the order for ARGB channels in registers. I suspect that, on
-// big endian machines, you can keep this the same and everything will work.
-// The in-memory order will be different, of course, but as long as everything
-// is reading memory as words rather than bytes, it will all work. However, if
-// you find that colours are messed up I thought that I would leave a helpful
-// locator for you. Also see the comments in
-// base/gfx/bitmap_platform_device_linux.h
-#error Read the comment at this location
-#endif
-
 #endif
 
 // These flags are no longer defined in Skia, but we have them (temporarily)
-- 
2.26.2

