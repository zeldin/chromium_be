From 6f5732e9f83f111fa835d3737afaa37ed86f6a76 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Tue, 2 Oct 2018 23:27:13 +0200
Subject: [PATCH 01/13] SkJSON: Fix tagged value implementation for big endian

---
 .../third_party/skia/src/utils/SkJSON.cpp     |  6 ++++-
 .../third_party/skia/src/utils/SkJSON.h       | 23 ++++++++++++++++---
 2 files changed, 25 insertions(+), 4 deletions(-)

diff --git a/src/3rdparty/chromium/third_party/skia/src/utils/SkJSON.cpp b/src/3rdparty/chromium/third_party/skia/src/utils/SkJSON.cpp
index b758f1fa9..d80b05175 100644
--- a/src/3rdparty/chromium/third_party/skia/src/utils/SkJSON.cpp
+++ b/src/3rdparty/chromium/third_party/skia/src/utils/SkJSON.cpp
@@ -34,6 +34,10 @@ void Value::init_tagged(Tag t) {
 
 // Pointer values store a type (in the upper kTagBits bits) and a pointer.
 void Value::init_tagged_pointer(Tag t, void* p) {
+#if !defined(SK_CPU_LENDIAN)
+    // Check that kRecAlign is large enough to leave room for the tag
+    static_assert(sizeof(Value) > sizeof(uintptr_t) || !(kRecAlign & Value::kTagMask), "kRecAlign is not a multiple of kTagMask+1");
+#endif
     *this->cast<uintptr_t>() = reinterpret_cast<uintptr_t>(p);
 
     if (sizeof(Value) == sizeof(uintptr_t)) {
@@ -169,7 +173,7 @@ private:
 #if defined(SK_CPU_LENDIAN)
         *s64 &= 0x00ffffffffffffffULL >> ((kMaxInlineStringSize - size) * 8);
 #else
-        static_assert(false, "Big-endian builds are not supported at this time.");
+        *s64 &= 0xffffffffffffff00ULL << ((kMaxInlineStringSize - size) * 8);
 #endif
     }
 };
diff --git a/src/3rdparty/chromium/third_party/skia/src/utils/SkJSON.h b/src/3rdparty/chromium/third_party/skia/src/utils/SkJSON.h
index 931b30f0a..0a28d0083 100644
--- a/src/3rdparty/chromium/third_party/skia/src/utils/SkJSON.h
+++ b/src/3rdparty/chromium/third_party/skia/src/utils/SkJSON.h
@@ -120,6 +120,7 @@ protected:
          -- highest 3 bits reserved for type storage
 
      */
+#if defined(SK_CPU_LENDIAN)
     enum class Tag : uint8_t {
         // We picked kShortString == 0 so that tag 0x00 and stored max_size-size (7-7=0)
         // conveniently overlap the '\0' terminator, allowing us to store a 7 character
@@ -134,6 +135,22 @@ protected:
         kObject                       = 0b11100000,  // ptr to external storage
     };
     static constexpr uint8_t kTagMask = 0b11100000;
+#else
+    enum class Tag : uint8_t {
+        // We picked kShortString == 0 so that tag 0x00 and stored max_size-size (7-7=0)
+        // conveniently overlap the '\0' terminator, allowing us to store a 7 character
+        // C string inline.
+        kShortString                  = 0b00000000,  // inline payload
+        kNull                         = 0b00000001,  // no payload
+        kBool                         = 0b00000010,  // inline payload
+        kInt                          = 0b00000011,  // inline payload
+        kFloat                        = 0b00000100,  // inline payload
+        kString                       = 0b00000101,  // ptr to external storage
+        kArray                        = 0b00000110,  // ptr to external storage
+        kObject                       = 0b00000111,  // ptr to external storage
+    };
+    static constexpr uint8_t kTagMask = 0b00000111;
+#endif
 
     void init_tagged(Tag);
     void init_tagged_pointer(Tag, void*);
@@ -192,14 +209,14 @@ private:
 
     uint8_t fData8[kValueSize];
 
-#if defined(SK_CPU_LENDIAN)
     static constexpr size_t kTagOffset = kValueSize - 1;
 
+#if defined(SK_CPU_LENDIAN)
     static constexpr uintptr_t kTagPointerMask =
             ~(static_cast<uintptr_t>(kTagMask) << ((sizeof(uintptr_t) - 1) * 8));
 #else
-    // The current value layout assumes LE and will take some tweaking for BE.
-    static_assert(false, "Big-endian builds are not supported at this time.");
+    static constexpr uintptr_t kTagPointerMask =
+            ~static_cast<uintptr_t>(kTagMask);
 #endif
 };
 
-- 
2.26.2


From 107fe95f07cbe94ceb5ca80282dfcf60ed5cc02f Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Wed, 3 Oct 2018 18:59:24 +0200
Subject: [PATCH 02/13] SkCodevPriv: Add missing include of SkEndian.h

---
 src/3rdparty/chromium/third_party/skia/src/codec/SkCodecPriv.h | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/3rdparty/chromium/third_party/skia/src/codec/SkCodecPriv.h b/src/3rdparty/chromium/third_party/skia/src/codec/SkCodecPriv.h
index 2f77fc70e..d2f2a37f3 100644
--- a/src/3rdparty/chromium/third_party/skia/src/codec/SkCodecPriv.h
+++ b/src/3rdparty/chromium/third_party/skia/src/codec/SkCodecPriv.h
@@ -14,6 +14,7 @@
 #include "include/private/SkColorData.h"
 #include "include/private/SkEncodedInfo.h"
 #include "src/codec/SkColorTable.h"
+#include "src/core/SkEndian.h"
 
 #ifdef SK_PRINT_CODEC_MESSAGES
     #define SkCodecPrintf SkDebugf
-- 
2.26.2


From a9aa8c3852ff0357a933fb39e6343d4330e83ad5 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Wed, 6 Mar 2019 20:18:48 +0100
Subject: [PATCH 03/13] portable::blit_row_s32a_opaque: Respect SK_A32_SHIFT

---
 .../chromium/third_party/skia/src/opts/SkBlitRow_opts.h       | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/3rdparty/chromium/third_party/skia/src/opts/SkBlitRow_opts.h b/src/3rdparty/chromium/third_party/skia/src/opts/SkBlitRow_opts.h
index 423d6ff77..11138a7a6 100644
--- a/src/3rdparty/chromium/third_party/skia/src/opts/SkBlitRow_opts.h
+++ b/src/3rdparty/chromium/third_party/skia/src/opts/SkBlitRow_opts.h
@@ -365,8 +365,8 @@ void blit_row_s32a_opaque(SkPMColor* dst, const SkPMColor* src, int len, U8CPU a
         // with chromium:611002 we need to keep it until we figure out where
         // the non-premultiplied src values (like 0x00FFFFFF) are coming from.
         // TODO(mtklein): sort this out and assert *src is premul here.
-        if (*src & 0xFF000000) {
-            *dst = (*src >= 0xFF000000) ? *src : SkPMSrcOver(*src, *dst);
+        if (*src & (0xFF << SK_A32_SHIFT)) {
+            *dst = ((*src << (24 - SK_A32_SHIFT)) >= 0xFF000000) ? *src : SkPMSrcOver(*src, *dst);
         }
         src++;
         dst++;
-- 
2.26.2


From 6aca27c8b850dd1a0c9b09d3112b397080c3d5b8 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Wed, 6 Mar 2019 20:21:59 +0100
Subject: [PATCH 04/13] skcms: skip swap in read_big_u{16,32} on BE

---
 .../chromium/third_party/skia/third_party/skcms/skcms.cc  | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/src/3rdparty/chromium/third_party/skia/third_party/skcms/skcms.cc b/src/3rdparty/chromium/third_party/skia/third_party/skcms/skcms.cc
index d6eb32ff3..25307d26c 100644
--- a/src/3rdparty/chromium/third_party/skia/third_party/skcms/skcms.cc
+++ b/src/3rdparty/chromium/third_party/skia/third_party/skcms/skcms.cc
@@ -281,21 +281,29 @@ enum {
 static uint16_t read_big_u16(const uint8_t* ptr) {
     uint16_t be;
     memcpy(&be, ptr, sizeof(be));
+#if __BIG_ENDIAN__
+    return be;
+#else
 #if defined(_MSC_VER)
     return _byteswap_ushort(be);
 #else
     return __builtin_bswap16(be);
 #endif
+#endif
 }
 
 static uint32_t read_big_u32(const uint8_t* ptr) {
     uint32_t be;
     memcpy(&be, ptr, sizeof(be));
+#if __BIG_ENDIAN__
+    return be;
+#else
 #if defined(_MSC_VER)
     return _byteswap_ulong(be);
 #else
     return __builtin_bswap32(be);
 #endif
+#endif
 }
 
 static int32_t read_big_i32(const uint8_t* ptr) {
-- 
2.26.2


From 33a16876727c88a0fbfbae748c21813df6138e16 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Wed, 27 Mar 2019 21:29:20 +0100
Subject: [PATCH 05/13] skcms: Handle endianness in transform code

---
 .../third_party/skcms/src/Transform_inl.h     | 165 ++++++++++++++++++
 1 file changed, 165 insertions(+)

diff --git a/src/3rdparty/chromium/third_party/skia/third_party/skcms/src/Transform_inl.h b/src/3rdparty/chromium/third_party/skia/third_party/skcms/src/Transform_inl.h
index c4b312286..4927106e0 100644
--- a/src/3rdparty/chromium/third_party/skia/third_party/skcms/src/Transform_inl.h
+++ b/src/3rdparty/chromium/third_party/skia/third_party/skcms/src/Transform_inl.h
@@ -507,9 +507,11 @@ SI U32 gather_32(const uint8_t* p, I32 ix) {
 }
 
 SI U32 gather_24(const uint8_t* p, I32 ix) {
+#if !__BIG_ENDIAN__
     // First, back up a byte.  Any place we're gathering from has a safe junk byte to read
     // in front of it, either a previous table value, or some tag metadata.
     p -= 1;
+#endif
 
     // Load the i'th 24-bit value from p, and 1 extra byte.
     auto load_24_32 = [p](int i) {
@@ -550,8 +552,10 @@ SI U32 gather_24(const uint8_t* p, I32 ix) {
 
 #if !defined(__arm__)
     SI void gather_48(const uint8_t* p, I32 ix, U64* v) {
+#if !__BIG_ENDIAN__
         // As in gather_24(), with everything doubled.
         p -= 2;
+#endif
 
         // Load the i'th 48-bit value from p, and 2 extra bytes.
         auto load_48_64 = [p](int i) {
@@ -614,9 +618,13 @@ SI F F_from_U8(U8 v) {
 SI F F_from_U16_BE(U16 v) {
     // All 16-bit ICC values are big-endian, so we byte swap before converting to float.
     // MSVC catches the "loss" of data here in the portable path, so we also make sure to mask.
+#if !__BIG_ENDIAN__
     U16 lo = (v >> 8),
         hi = (v << 8) & 0xffff;
     return cast<F>(lo|hi) * (1/65535.0f);
+#else
+    return cast<F>(v) * (1/65535.0f);
+#endif
 }
 
 SI U16 U16_from_F(F v) {
@@ -659,9 +667,15 @@ SI F table(const skcms_Curve* curve, F v) {
 SI void sample_clut_8(const skcms_A2B* a2b, I32 ix, F* r, F* g, F* b) {
     U32 rgb = gather_24(a2b->grid_8, ix);
 
+#if __BIG_ENDIAN__
+    *r = cast<F>((rgb >> 16) & 0xff) * (1/255.0f);
+    *g = cast<F>((rgb >>  8) & 0xff) * (1/255.0f);
+    *b = cast<F>((rgb >>  0) & 0xff) * (1/255.0f);
+#else
     *r = cast<F>((rgb >>  0) & 0xff) * (1/255.0f);
     *g = cast<F>((rgb >>  8) & 0xff) * (1/255.0f);
     *b = cast<F>((rgb >> 16) & 0xff) * (1/255.0f);
+#endif
 }
 
 SI void sample_clut_16(const skcms_A2B* a2b, I32 ix, F* r, F* g, F* b) {
@@ -674,12 +688,18 @@ SI void sample_clut_16(const skcms_A2B* a2b, I32 ix, F* r, F* g, F* b) {
     // This strategy is much faster for 64-bit builds, and fine for 32-bit x86 too.
     U64 rgb;
     gather_48(a2b->grid_16, ix, &rgb);
+#if __BIG_ENDIAN__
+    *r = cast<F>((rgb >> 32) & 0xffff) * (1/65535.0f);
+    *g = cast<F>((rgb >> 16) & 0xffff) * (1/65535.0f);
+    *b = cast<F>((rgb >>  0) & 0xffff) * (1/65535.0f);
+#else
     rgb = swap_endian_16x4(rgb);
 
     *r = cast<F>((rgb >>  0) & 0xffff) * (1/65535.0f);
     *g = cast<F>((rgb >> 16) & 0xffff) * (1/65535.0f);
     *b = cast<F>((rgb >> 32) & 0xffff) * (1/65535.0f);
 #endif
+#endif
 }
 
 // GCC 7.2.0 hits an internal compiler error with -finline-functions (or -O3)
@@ -837,10 +857,17 @@ static void exec_ops(const Op* ops, const void** args,
             case Op_load_8888:{
                 U32 rgba = load<U32>(src + 4*i);
 
+#if __BIG_ENDIAN__
+                r = cast<F>((rgba >> 24) & 0xff) * (1/255.0f);
+                g = cast<F>((rgba >> 16) & 0xff) * (1/255.0f);
+                b = cast<F>((rgba >>  8) & 0xff) * (1/255.0f);
+                a = cast<F>((rgba >>  0) & 0xff) * (1/255.0f);
+#else
                 r = cast<F>((rgba >>  0) & 0xff) * (1/255.0f);
                 g = cast<F>((rgba >>  8) & 0xff) * (1/255.0f);
                 b = cast<F>((rgba >> 16) & 0xff) * (1/255.0f);
                 a = cast<F>((rgba >> 24) & 0xff) * (1/255.0f);
+#endif
             } break;
 
             case Op_load_8888_palette8:{
@@ -874,13 +901,29 @@ static void exec_ops(const Op* ops, const void** args,
                 b = cast<F>((U16)v.val[2]) * (1/65535.0f);
             #elif defined(USING_NEON)
                 uint16x4x3_t v = vld3_u16(rgb);
+#if __BIG_ENDIAN__
+                r = cast<F>(swap_endian_16((U16)v.val[0])) * (1/65535.0f);
+                g = cast<F>(swap_endian_16((U16)v.val[1])) * (1/65535.0f);
+                b = cast<F>(swap_endian_16((U16)v.val[2])) * (1/65535.0f);
+#else
                 r = cast<F>((U16)v.val[0]) * (1/65535.0f);
                 g = cast<F>((U16)v.val[1]) * (1/65535.0f);
                 b = cast<F>((U16)v.val[2]) * (1/65535.0f);
+#endif
             #else
+#if __BIG_ENDIAN__
+                U32 R = load_3<U32>(rgb+0),
+                    G = load_3<U32>(rgb+1),
+                    B = load_3<U32>(rgb+2);
+                // R,G,B are little-endian 16-bit, so byte swap them before converting to float.
+                r = cast<F>((R & 0x00ff)<<8 | (R & 0xff00)>>8) * (1/65535.0f);
+                g = cast<F>((G & 0x00ff)<<8 | (G & 0xff00)>>8) * (1/65535.0f);
+                b = cast<F>((B & 0x00ff)<<8 | (B & 0xff00)>>8) * (1/65535.0f);
+#else
                 r = cast<F>(load_3<U32>(rgb+0)) * (1/65535.0f);
                 g = cast<F>(load_3<U32>(rgb+1)) * (1/65535.0f);
                 b = cast<F>(load_3<U32>(rgb+2)) * (1/65535.0f);
+#endif
             #endif
             } break;
 
@@ -896,17 +939,33 @@ static void exec_ops(const Op* ops, const void** args,
                 a = cast<F>((U16)v.val[3]) * (1/65535.0f);
             #elif defined(USING_NEON)
                 uint16x4x4_t v = vld4_u16(rgba);
+#if __BIG_ENDIAN__
+                r = cast<F>(swap_endian_16((U16)v.val[0])) * (1/65535.0f);
+                g = cast<F>(swap_endian_16((U16)v.val[1])) * (1/65535.0f);
+                b = cast<F>(swap_endian_16((U16)v.val[2])) * (1/65535.0f);
+                a = cast<F>(swap_endian_16((U16)v.val[3])) * (1/65535.0f);
+#else
                 r = cast<F>((U16)v.val[0]) * (1/65535.0f);
                 g = cast<F>((U16)v.val[1]) * (1/65535.0f);
                 b = cast<F>((U16)v.val[2]) * (1/65535.0f);
                 a = cast<F>((U16)v.val[3]) * (1/65535.0f);
+#endif
             #else
+#if __BIG_ENDIAN__
+                U64 px = swap_endian_16x4(load<U64>(rgba));
+
+                r = cast<F>((px >> 48) & 0xffff) * (1/65535.0f);
+                g = cast<F>((px >> 32) & 0xffff) * (1/65535.0f);
+                b = cast<F>((px >> 16) & 0xffff) * (1/65535.0f);
+                a = cast<F>((px >>  0) & 0xffff) * (1/65535.0f);
+#else
                 U64 px = load<U64>(rgba);
 
                 r = cast<F>((px >>  0) & 0xffff) * (1/65535.0f);
                 g = cast<F>((px >> 16) & 0xffff) * (1/65535.0f);
                 b = cast<F>((px >> 32) & 0xffff) * (1/65535.0f);
                 a = cast<F>((px >> 48) & 0xffff) * (1/65535.0f);
+#endif
             #endif
             } break;
 
@@ -921,10 +980,21 @@ static void exec_ops(const Op* ops, const void** args,
                 b = cast<F>(swap_endian_16((U16)v.val[2])) * (1/65535.0f);
             #elif defined(USING_NEON)
                 uint16x4x3_t v = vld3_u16(rgb);
+#if __BIG_ENDIAN__
+                r = cast<F>((U16)v.val[0]) * (1/65535.0f);
+                g = cast<F>((U16)v.val[1]) * (1/65535.0f);
+                b = cast<F>((U16)v.val[2]) * (1/65535.0f);
+#else
                 r = cast<F>(swap_endian_16((U16)v.val[0])) * (1/65535.0f);
                 g = cast<F>(swap_endian_16((U16)v.val[1])) * (1/65535.0f);
                 b = cast<F>(swap_endian_16((U16)v.val[2])) * (1/65535.0f);
+#endif
             #else
+#if __BIG_ENDIAN__
+                r = cast<F>(load_3<U32>(rgb+0)) * (1/65535.0f);
+                g = cast<F>(load_3<U32>(rgb+1)) * (1/65535.0f);
+                b = cast<F>(load_3<U32>(rgb+2)) * (1/65535.0f);
+#else
                 U32 R = load_3<U32>(rgb+0),
                     G = load_3<U32>(rgb+1),
                     B = load_3<U32>(rgb+2);
@@ -932,6 +1002,7 @@ static void exec_ops(const Op* ops, const void** args,
                 r = cast<F>((R & 0x00ff)<<8 | (R & 0xff00)>>8) * (1/65535.0f);
                 g = cast<F>((G & 0x00ff)<<8 | (G & 0xff00)>>8) * (1/65535.0f);
                 b = cast<F>((B & 0x00ff)<<8 | (B & 0xff00)>>8) * (1/65535.0f);
+#endif
             #endif
             } break;
 
@@ -947,17 +1018,33 @@ static void exec_ops(const Op* ops, const void** args,
                 a = cast<F>(swap_endian_16((U16)v.val[3])) * (1/65535.0f);
             #elif defined(USING_NEON)
                 uint16x4x4_t v = vld4_u16(rgba);
+#if __BIG_ENDIAN__
+                r = cast<F>((U16)v.val[0]) * (1/65535.0f);
+                g = cast<F>((U16)v.val[1]) * (1/65535.0f);
+                b = cast<F>((U16)v.val[2]) * (1/65535.0f);
+                a = cast<F>((U16)v.val[3]) * (1/65535.0f);
+#else
                 r = cast<F>(swap_endian_16((U16)v.val[0])) * (1/65535.0f);
                 g = cast<F>(swap_endian_16((U16)v.val[1])) * (1/65535.0f);
                 b = cast<F>(swap_endian_16((U16)v.val[2])) * (1/65535.0f);
                 a = cast<F>(swap_endian_16((U16)v.val[3])) * (1/65535.0f);
+#endif
             #else
+#if __BIG_ENDIAN__
+                U64 px = load<U64>(rgba);
+
+                r = cast<F>((px >> 48) & 0xffff) * (1/65535.0f);
+                g = cast<F>((px >> 32) & 0xffff) * (1/65535.0f);
+                b = cast<F>((px >> 16) & 0xffff) * (1/65535.0f);
+                a = cast<F>((px >>  0) & 0xffff) * (1/65535.0f);
+#else
                 U64 px = swap_endian_16x4(load<U64>(rgba));
 
                 r = cast<F>((px >>  0) & 0xffff) * (1/65535.0f);
                 g = cast<F>((px >> 16) & 0xffff) * (1/65535.0f);
                 b = cast<F>((px >> 32) & 0xffff) * (1/65535.0f);
                 a = cast<F>((px >> 48) & 0xffff) * (1/65535.0f);
+#endif
             #endif
             } break;
 
@@ -1003,10 +1090,17 @@ static void exec_ops(const Op* ops, const void** args,
                     A = (U16)v.val[3];
             #else
                 U64 px = load<U64>(rgba);
+#if __BIG_ENDIAN__
+                U16 R = cast<U16>((px >> 48) & 0xffff),
+                    G = cast<U16>((px >> 32) & 0xffff),
+                    B = cast<U16>((px >> 16) & 0xffff),
+                    A = cast<U16>((px >>  0) & 0xffff);
+#else
                 U16 R = cast<U16>((px >>  0) & 0xffff),
                     G = cast<U16>((px >> 16) & 0xffff),
                     B = cast<U16>((px >> 32) & 0xffff),
                     A = cast<U16>((px >> 48) & 0xffff);
+#endif
             #endif
                 r = F_from_Half(R);
                 g = F_from_Half(G);
@@ -1243,10 +1337,17 @@ static void exec_ops(const Op* ops, const void** args,
             } return;
 
             case Op_store_8888: {
+#if __BIG_ENDIAN__
+                store(dst + 4*i, cast<U32>(to_fixed(r * 255)) << 24
+                               | cast<U32>(to_fixed(g * 255)) << 16
+                               | cast<U32>(to_fixed(b * 255)) <<  8
+                               | cast<U32>(to_fixed(a * 255)) <<  0);
+#else
                 store(dst + 4*i, cast<U32>(to_fixed(r * 255)) <<  0
                                | cast<U32>(to_fixed(g * 255)) <<  8
                                | cast<U32>(to_fixed(b * 255)) << 16
                                | cast<U32>(to_fixed(a * 255)) << 24);
+#endif
             } return;
 
             case Op_store_1010102: {
@@ -1269,15 +1370,30 @@ static void exec_ops(const Op* ops, const void** args,
                 vst3q_u16(rgb, v);
             #elif defined(USING_NEON)
                 uint16x4x3_t v = {{
+#if __BIG_ENDIAN__
+                    (uint16x4_t)swap_endian_16(cast<U16>(U16_from_F(r))),
+                    (uint16x4_t)swap_endian_16(cast<U16>(U16_from_F(g))),
+                    (uint16x4_t)swap_endian_16(cast<U16>(U16_from_F(b))),
+#else
                     (uint16x4_t)U16_from_F(r),
                     (uint16x4_t)U16_from_F(g),
                     (uint16x4_t)U16_from_F(b),
+#endif
                 }};
                 vst3_u16(rgb, v);
             #else
+#if __BIG_ENDIAN__
+                U32 R = to_fixed(r * 65535),
+                    G = to_fixed(g * 65535),
+                    B = to_fixed(b * 65535);
+                store_3(rgb+0, cast<U16>((R & 0x00ff) << 8 | (R & 0xff00) >> 8) );
+                store_3(rgb+1, cast<U16>((G & 0x00ff) << 8 | (G & 0xff00) >> 8) );
+                store_3(rgb+2, cast<U16>((B & 0x00ff) << 8 | (B & 0xff00) >> 8) );
+#else
                 store_3(rgb+0, U16_from_F(r));
                 store_3(rgb+1, U16_from_F(g));
                 store_3(rgb+2, U16_from_F(b));
+#endif
             #endif
 
             } return;
@@ -1296,18 +1412,33 @@ static void exec_ops(const Op* ops, const void** args,
                 vst4q_u16(rgba, v);
             #elif defined(USING_NEON)
                 uint16x4x4_t v = {{
+#if __BIG_ENDIAN__
+                    (uint16x4_t)swap_endian_16(cast<U16>(U16_from_F(r))),
+                    (uint16x4_t)swap_endian_16(cast<U16>(U16_from_F(g))),
+                    (uint16x4_t)swap_endian_16(cast<U16>(U16_from_F(b))),
+                    (uint16x4_t)swap_endian_16(cast<U16>(U16_from_F(a))),
+#else
                     (uint16x4_t)U16_from_F(r),
                     (uint16x4_t)U16_from_F(g),
                     (uint16x4_t)U16_from_F(b),
                     (uint16x4_t)U16_from_F(a),
+#endif
                 }};
                 vst4_u16(rgba, v);
             #else
+#if __BIG_ENDIAN__
+                U64 px = cast<U64>(to_fixed(r * 65535)) << 48
+                       | cast<U64>(to_fixed(g * 65535)) << 32
+                       | cast<U64>(to_fixed(b * 65535)) << 16
+                       | cast<U64>(to_fixed(a * 65535)) <<  0;
+                store(rgba, swap_endian_16x4(px));
+#else
                 U64 px = cast<U64>(to_fixed(r * 65535)) <<  0
                        | cast<U64>(to_fixed(g * 65535)) << 16
                        | cast<U64>(to_fixed(b * 65535)) << 32
                        | cast<U64>(to_fixed(a * 65535)) << 48;
                 store(rgba, px);
+#endif
             #endif
             } return;
 
@@ -1324,18 +1455,30 @@ static void exec_ops(const Op* ops, const void** args,
                 vst3q_u16(rgb, v);
             #elif defined(USING_NEON)
                 uint16x4x3_t v = {{
+#if __BIG_ENDIAN__
+                    (uint16x4_t)U16_from_F(r),
+                    (uint16x4_t)U16_from_F(g),
+                    (uint16x4_t)U16_from_F(b),
+#else
                     (uint16x4_t)swap_endian_16(cast<U16>(U16_from_F(r))),
                     (uint16x4_t)swap_endian_16(cast<U16>(U16_from_F(g))),
                     (uint16x4_t)swap_endian_16(cast<U16>(U16_from_F(b))),
+#endif
                 }};
                 vst3_u16(rgb, v);
             #else
+#if __BIG_ENDIAN__
+                store_3(rgb+0, U16_from_F(r));
+                store_3(rgb+1, U16_from_F(g));
+                store_3(rgb+2, U16_from_F(b));
+#else
                 U32 R = to_fixed(r * 65535),
                     G = to_fixed(g * 65535),
                     B = to_fixed(b * 65535);
                 store_3(rgb+0, cast<U16>((R & 0x00ff) << 8 | (R & 0xff00) >> 8) );
                 store_3(rgb+1, cast<U16>((G & 0x00ff) << 8 | (G & 0xff00) >> 8) );
                 store_3(rgb+2, cast<U16>((B & 0x00ff) << 8 | (B & 0xff00) >> 8) );
+#endif
             #endif
 
             } return;
@@ -1354,18 +1497,33 @@ static void exec_ops(const Op* ops, const void** args,
                 vst4q_u16(rgba, v);
             #elif defined(USING_NEON)
                 uint16x4x4_t v = {{
+#if __BIG_ENDIAN__
+                    (uint16x4_t)U16_from_F(r),
+                    (uint16x4_t)U16_from_F(g),
+                    (uint16x4_t)U16_from_F(b),
+                    (uint16x4_t)U16_from_F(a),
+#else
                     (uint16x4_t)swap_endian_16(cast<U16>(U16_from_F(r))),
                     (uint16x4_t)swap_endian_16(cast<U16>(U16_from_F(g))),
                     (uint16x4_t)swap_endian_16(cast<U16>(U16_from_F(b))),
                     (uint16x4_t)swap_endian_16(cast<U16>(U16_from_F(a))),
+#endif
                 }};
                 vst4_u16(rgba, v);
             #else
+#if __BIG_ENDIAN__
+                U64 px = cast<U64>(to_fixed(r * 65535)) << 48
+                       | cast<U64>(to_fixed(g * 65535)) << 32
+                       | cast<U64>(to_fixed(b * 65535)) << 16
+                       | cast<U64>(to_fixed(a * 65535)) <<  0;
+                store(rgba, px);
+#else
                 U64 px = cast<U64>(to_fixed(r * 65535)) <<  0
                        | cast<U64>(to_fixed(g * 65535)) << 16
                        | cast<U64>(to_fixed(b * 65535)) << 32
                        | cast<U64>(to_fixed(a * 65535)) << 48;
                 store(rgba, swap_endian_16x4(px));
+#endif
             #endif
             } return;
 
@@ -1424,10 +1582,17 @@ static void exec_ops(const Op* ops, const void** args,
                 }};
                 vst4_u16(rgba, v);
             #else
+#if __BIG_ENDIAN__
+                store(rgba, cast<U64>(R) << 48
+                          | cast<U64>(G) << 32
+                          | cast<U64>(B) << 16
+                          | cast<U64>(A) <<  0);
+#else
                 store(rgba, cast<U64>(R) <<  0
                           | cast<U64>(G) << 16
                           | cast<U64>(B) << 32
                           | cast<U64>(A) << 48);
+#endif
             #endif
 
             } return;
-- 
2.26.2


From 41a7bcc1ae40af489eef518ed6a884d79af57756 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Sat, 6 Apr 2019 23:32:18 +0200
Subject: [PATCH 06/13] SkRasterPipeline_opts: Handle endianness in 32-bit
 pixel load/store

---
 .../skia/src/opts/SkRasterPipeline_opts.h     | 40 +++++++++++++++++++
 1 file changed, 40 insertions(+)

diff --git a/src/3rdparty/chromium/third_party/skia/src/opts/SkRasterPipeline_opts.h b/src/3rdparty/chromium/third_party/skia/src/opts/SkRasterPipeline_opts.h
index 0d610ccfe..3607c936b 100644
--- a/src/3rdparty/chromium/third_party/skia/src/opts/SkRasterPipeline_opts.h
+++ b/src/3rdparty/chromium/third_party/skia/src/opts/SkRasterPipeline_opts.h
@@ -1210,10 +1210,17 @@ SI void from_4444(U16 _4444, F* r, F* g, F* b, F* a) {
     *a = cast(wide & (15<< 0)) * (1.0f / (15<< 0));
 }
 SI void from_8888(U32 _8888, F* r, F* g, F* b, F* a) {
+#ifdef SK_CPU_BENDIAN
+    *r = cast((_8888 >> 24)       ) * (1/255.0f);
+    *g = cast((_8888 >> 16) & 0xff) * (1/255.0f);
+    *b = cast((_8888 >>  8) & 0xff) * (1/255.0f);
+    *a = cast((_8888      ) & 0xff) * (1/255.0f);
+#else
     *r = cast((_8888      ) & 0xff) * (1/255.0f);
     *g = cast((_8888 >>  8) & 0xff) * (1/255.0f);
     *b = cast((_8888 >> 16) & 0xff) * (1/255.0f);
     *a = cast((_8888 >> 24)       ) * (1/255.0f);
+#endif
 }
 SI void from_88(U16 _88, F* r, F* g) {
     U32 wide = expand(_88);
@@ -1575,10 +1582,17 @@ STAGE(srcover_rgba_8888, const SkRasterPipeline_MemoryCtx* ctx) {
     auto ptr = ptr_at_xy<uint32_t>(ctx, dx,dy);
 
     U32 dst = load<U32>(ptr, tail);
+#ifdef SK_CPU_BENDIAN
+    dr = cast((dst >> 24)       );
+    dg = cast((dst >> 16) & 0xff);
+    db = cast((dst >>  8) & 0xff);
+    da = cast((dst      ) & 0xff);
+#else
     dr = cast((dst      ) & 0xff);
     dg = cast((dst >>  8) & 0xff);
     db = cast((dst >> 16) & 0xff);
     da = cast((dst >> 24)       );
+#endif
     // {dr,dg,db,da} are in [0,255]
     // { r, g, b, a} are in [0,  1] (but may be out of gamut)
 
@@ -1589,10 +1603,17 @@ STAGE(srcover_rgba_8888, const SkRasterPipeline_MemoryCtx* ctx) {
     // { r, g, b, a} are now in [0,255]  (but may be out of gamut)
 
     // to_unorm() clamps back to gamut.  Scaling by 1 since we're already 255-biased.
+#ifdef SK_CPU_BENDIAN
+    dst = to_unorm(r, 1, 255) << 24
+        | to_unorm(g, 1, 255) << 16
+        | to_unorm(b, 1, 255) <<  8
+        | to_unorm(a, 1, 255);
+#else
     dst = to_unorm(r, 1, 255)
         | to_unorm(g, 1, 255) <<  8
         | to_unorm(b, 1, 255) << 16
         | to_unorm(a, 1, 255) << 24;
+#endif
     store(ptr, dst, tail);
 }
 
@@ -2042,10 +2063,17 @@ STAGE(gather_8888, const SkRasterPipeline_GatherCtx* ctx) {
 STAGE(store_8888, const SkRasterPipeline_MemoryCtx* ctx) {
     auto ptr = ptr_at_xy<uint32_t>(ctx, dx,dy);
 
+#ifdef SK_CPU_BENDIAN
+    U32 px = to_unorm(r, 255) << 24
+           | to_unorm(g, 255) << 16
+           | to_unorm(b, 255) <<  8
+           | to_unorm(a, 255);
+#else
     U32 px = to_unorm(r, 255)
            | to_unorm(g, 255) <<  8
            | to_unorm(b, 255) << 16
            | to_unorm(a, 255) << 24;
+#endif
     store(ptr, px, tail);
 }
 
@@ -3542,10 +3570,17 @@ SI void from_8888(U32 rgba, U16* r, U16* g, U16* b, U16* a) {
         return cast<U16>(v);
     };
 #endif
+#ifdef SK_CPU_BENDIAN
+    *r = cast_U16(rgba >>   16) >>  8;
+    *g = cast_U16(rgba >>   16) & 255;
+    *b = cast_U16(rgba & 65535) >>  8;
+    *a = cast_U16(rgba & 65535) & 255;
+#else
     *r = cast_U16(rgba & 65535) & 255;
     *g = cast_U16(rgba & 65535) >>  8;
     *b = cast_U16(rgba >>   16) & 255;
     *a = cast_U16(rgba >>   16) >>  8;
+#endif
 }
 
 SI void load_8888_(const uint32_t* ptr, size_t tail, U16* r, U16* g, U16* b, U16* a) {
@@ -3587,10 +3622,15 @@ SI void store_8888_(uint32_t* ptr, size_t tail, U16 r, U16 g, U16 b, U16 a) {
         case 2: vst4_lane_u8((uint8_t*)(ptr+1), rgba, 1);
         case 1: vst4_lane_u8((uint8_t*)(ptr+0), rgba, 0);
     }
+#else
+#ifdef SK_CPU_BENDIAN
+    store(ptr, tail, cast<U32>((r<<8) | g) << 16
+                   | cast<U32>((b<<8) | a) << 0);
 #else
     store(ptr, tail, cast<U32>(r | (g<<8)) <<  0
                    | cast<U32>(b | (a<<8)) << 16);
 #endif
+#endif
 }
 
 STAGE_PP(load_8888, const SkRasterPipeline_MemoryCtx* ctx) {
-- 
2.26.2


From b0423bb99eaf7f28f1e20aa7de3c72d605d3e394 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Sun, 7 Apr 2019 12:00:05 +0200
Subject: [PATCH 07/13] SkPixmap: Fix getColor on pixmaps with non-premul alpha

The trick to use SkSwizzle_BGRA_to_PMColor() to get an SkColor from an
SkPMColor only works on LE, because an SkColor is actually fixed as
ARGB in register order, so on BE it becomes ARGB is memory order, not BGRA.
---
 src/3rdparty/chromium/third_party/skia/src/core/SkPixmap.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/3rdparty/chromium/third_party/skia/src/core/SkPixmap.cpp b/src/3rdparty/chromium/third_party/skia/src/core/SkPixmap.cpp
index c8a09ff7c..2089784a3 100644
--- a/src/3rdparty/chromium/third_party/skia/src/core/SkPixmap.cpp
+++ b/src/3rdparty/chromium/third_party/skia/src/core/SkPixmap.cpp
@@ -266,7 +266,8 @@ SkColor SkPixmap::getColor(int x, int y) const {
     const bool needsUnpremul = (kPremul_SkAlphaType == fInfo.alphaType());
     auto toColor = [needsUnpremul](uint32_t maybePremulColor) {
         return needsUnpremul ? SkUnPreMultiply::PMColorToColor(maybePremulColor)
-                             : SkSwizzle_BGRA_to_PMColor(maybePremulColor);
+                             : SkColorSetARGB(SkGetPackedA32(maybePremulColor), SkGetPackedR32(maybePremulColor),
+					      SkGetPackedG32(maybePremulColor), SkGetPackedB32(maybePremulColor));
     };
 
     switch (this->colorType()) {
-- 
2.26.2


From a2e09e509a9bb9f2e712c3684246b70de273b7ef Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Sun, 7 Apr 2019 21:12:17 +0200
Subject: [PATCH 08/13] skcms: skip swap in eval_curve on BE

---
 .../chromium/third_party/skia/third_party/skcms/skcms.cc     | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/src/3rdparty/chromium/third_party/skia/third_party/skcms/skcms.cc b/src/3rdparty/chromium/third_party/skia/third_party/skcms/skcms.cc
index 25307d26c..fd436c428 100644
--- a/src/3rdparty/chromium/third_party/skia/third_party/skcms/skcms.cc
+++ b/src/3rdparty/chromium/third_party/skia/third_party/skcms/skcms.cc
@@ -222,10 +222,15 @@ static float eval_curve(const skcms_Curve* curve, float x) {
         uint16_t be_l, be_h;
         memcpy(&be_l, curve->table_16 + 2*lo, 2);
         memcpy(&be_h, curve->table_16 + 2*hi, 2);
+#if __BIG_ENDIAN__
+        l = be_l * (1/65535.0f);
+        h = be_h * (1/65535.0f);
+#else
         uint16_t le_l = ((be_l << 8) | (be_l >> 8)) & 0xffff;
         uint16_t le_h = ((be_h << 8) | (be_h >> 8)) & 0xffff;
         l = le_l * (1/65535.0f);
         h = le_h * (1/65535.0f);
+#endif
     }
     return l + (h-l)*t;
 }
-- 
2.26.2


From b132016a958c48536b8493c4c13ab2a409320e37 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Sat, 18 May 2019 11:20:48 +0200
Subject: [PATCH 09/13] SkColor: Fix conversion between SkColor4f and SkColor

SkColor4f is a vector of 4 floats with the fixed component order
<R, G, B, A>.  SkColor on the other hand is defined as a single
32-bit number with the value 0xAARRGGBB.  When converting this
to/from a vector using Sk4f_fromL32 and Sk4f_toL32, the vector
becomes <A, R, G, B> on BE and <B, G, R, A> on LE.  Thus different
swizzles are needed to get to/from the order <R, G, B, A>.

Fix courtesy of awilfox.
---
 .../third_party/skia/src/core/SkColor.cpp     | 20 +++++++++++++++++--
 1 file changed, 18 insertions(+), 2 deletions(-)

diff --git a/src/3rdparty/chromium/third_party/skia/src/core/SkColor.cpp b/src/3rdparty/chromium/third_party/skia/src/core/SkColor.cpp
index efcc4b9c4..38f619bdb 100644
--- a/src/3rdparty/chromium/third_party/skia/src/core/SkColor.cpp
+++ b/src/3rdparty/chromium/third_party/skia/src/core/SkColor.cpp
@@ -108,13 +108,29 @@ SkColor SkHSVToColor(U8CPU a, const SkScalar hsv[3]) {
 template <>
 SkColor4f SkColor4f::FromColor(SkColor bgra) {
     SkColor4f rgba;
-    swizzle_rb(Sk4f_fromL32(bgra)).store(rgba.vec());
+    Sk4f c4f = Sk4f_fromL32(bgra);
+#ifdef SK_CPU_BENDIAN
+    // ARGB -> RGBA
+    c4f = SkNx_shuffle<1, 2, 3, 0>(c4f);
+#else
+    // BGRA -> RGBA
+    c4f = swizzle_rb(c4f);
+#endif
+    c4f.store(rgba.vec());
     return rgba;
 }
 
 template <>
 SkColor SkColor4f::toSkColor() const {
-    return Sk4f_toL32(swizzle_rb(Sk4f::Load(this->vec())));
+    Sk4f c4f = Sk4f::Load(this->vec());
+#ifdef SK_CPU_BENDIAN
+    // RGBA -> ARGB
+    c4f = SkNx_shuffle<3, 0, 1, 2>(c4f);
+#else
+    // RGBA -> BGRA
+    c4f = swizzle_rb(c4f);
+#endif
+    return Sk4f_toL32(c4f);
 }
 
 template <>
-- 
2.26.2


From 1b7f325f7b6c72d54a34266805f6ea6cc76aff70 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Sat, 18 May 2019 11:32:47 +0200
Subject: [PATCH 10/13] Remove some endianness asserts

---
 .../chromium/third_party/skia/include/core/SkPostConfig.h      | 2 ++
 .../chromium/third_party/skia/include/private/GrTypesPriv.h    | 3 ---
 src/3rdparty/chromium/third_party/skia/src/opts/Sk4px_none.h   | 1 -
 3 files changed, 2 insertions(+), 4 deletions(-)

diff --git a/src/3rdparty/chromium/third_party/skia/include/core/SkPostConfig.h b/src/3rdparty/chromium/third_party/skia/include/core/SkPostConfig.h
index 0120944c0..e4201d99d 100644
--- a/src/3rdparty/chromium/third_party/skia/include/core/SkPostConfig.h
+++ b/src/3rdparty/chromium/third_party/skia/include/core/SkPostConfig.h
@@ -40,6 +40,8 @@
 #  error "must define either SK_CPU_LENDIAN or SK_CPU_BENDIAN"
 #endif
 
+#define I_ACKNOWLEDGE_SKIA_DOES_NOT_SUPPORT_BIG_ENDIAN
+
 #if defined(SK_CPU_BENDIAN) && !defined(I_ACKNOWLEDGE_SKIA_DOES_NOT_SUPPORT_BIG_ENDIAN)
     #error "The Skia team is not endian-savvy enough to support big-endian CPUs."
     #error "If you still want to use Skia,"
diff --git a/src/3rdparty/chromium/third_party/skia/include/private/GrTypesPriv.h b/src/3rdparty/chromium/third_party/skia/include/private/GrTypesPriv.h
index 28a0abcfa..d3bf23748 100644
--- a/src/3rdparty/chromium/third_party/skia/include/private/GrTypesPriv.h
+++ b/src/3rdparty/chromium/third_party/skia/include/private/GrTypesPriv.h
@@ -70,9 +70,6 @@ enum GrPixelConfig {
 static const int kGrPixelConfigCnt = kLast_GrPixelConfig + 1;
 
 // Aliases for pixel configs that match skia's byte order.
-#ifndef SK_CPU_LENDIAN
-#error "Skia gpu currently assumes little endian"
-#endif
 #if SK_PMCOLOR_BYTE_ORDER(B,G,R,A)
 static const GrPixelConfig kSkia8888_GrPixelConfig = kBGRA_8888_GrPixelConfig;
 #elif SK_PMCOLOR_BYTE_ORDER(R,G,B,A)
diff --git a/src/3rdparty/chromium/third_party/skia/src/opts/Sk4px_none.h b/src/3rdparty/chromium/third_party/skia/src/opts/Sk4px_none.h
index 41e8168bb..8de68419d 100644
--- a/src/3rdparty/chromium/third_party/skia/src/opts/Sk4px_none.h
+++ b/src/3rdparty/chromium/third_party/skia/src/opts/Sk4px_none.h
@@ -35,7 +35,6 @@ inline Sk4px Sk4px::Wide::div255() const {
 }
 
 inline Sk4px Sk4px::alphas() const {
-    static_assert(SK_A32_SHIFT == 24, "This method assumes little-endian.");
     return Sk16b((*this)[ 3], (*this)[ 3], (*this)[ 3], (*this)[ 3],
                  (*this)[ 7], (*this)[ 7], (*this)[ 7], (*this)[ 7],
                  (*this)[11], (*this)[11], (*this)[11], (*this)[11],
-- 
2.26.2


From 668cd6875fba861f90cc6409f029cae1c88a3035 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Wed, 6 Jan 2021 13:40:58 +0100
Subject: [PATCH 11/13] Fix RGBA and BGRA shifts on big endian

---
 .../third_party/skia/include/core/SkColorPriv.h  | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/src/3rdparty/chromium/third_party/skia/include/core/SkColorPriv.h b/src/3rdparty/chromium/third_party/skia/include/core/SkColorPriv.h
index 7078d92ac..6cd0573f6 100644
--- a/src/3rdparty/chromium/third_party/skia/include/core/SkColorPriv.h
+++ b/src/3rdparty/chromium/third_party/skia/include/core/SkColorPriv.h
@@ -56,6 +56,20 @@ static inline U8CPU SkUnitScalarClampToByte(SkScalar x) {
  *  Here we enforce this constraint.
  */
 
+#if defined(SK_CPU_BENDIAN)
+
+#define SK_RGBA_R32_SHIFT   24
+#define SK_RGBA_G32_SHIFT   16
+#define SK_RGBA_B32_SHIFT   8
+#define SK_RGBA_A32_SHIFT   0
+
+#define SK_BGRA_B32_SHIFT   24
+#define SK_BGRA_G32_SHIFT   16
+#define SK_BGRA_R32_SHIFT   8
+#define SK_BGRA_A32_SHIFT   0
+
+#else
+
 #define SK_RGBA_R32_SHIFT   0
 #define SK_RGBA_G32_SHIFT   8
 #define SK_RGBA_B32_SHIFT   16
@@ -66,6 +80,8 @@ static inline U8CPU SkUnitScalarClampToByte(SkScalar x) {
 #define SK_BGRA_R32_SHIFT   16
 #define SK_BGRA_A32_SHIFT   24
 
+#endif
+
 #if defined(SK_PMCOLOR_IS_RGBA) || defined(SK_PMCOLOR_IS_BGRA)
     #error "Configure PMCOLOR by setting SK_R32_SHIFT."
 #endif
-- 
2.26.2


From a3edb9ab47f2a0f842fcaf8c103be151126cc677 Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Wed, 6 Jan 2021 13:42:39 +0100
Subject: [PATCH 12/13] Avoid redefining SK_G32_SHIFT and SK_A32_SHIFT

---
 .../chromium/third_party/skia/include/core/SkPostConfig.h     | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/src/3rdparty/chromium/third_party/skia/include/core/SkPostConfig.h b/src/3rdparty/chromium/third_party/skia/include/core/SkPostConfig.h
index e4201d99d..bd5aebbd0 100644
--- a/src/3rdparty/chromium/third_party/skia/include/core/SkPostConfig.h
+++ b/src/3rdparty/chromium/third_party/skia/include/core/SkPostConfig.h
@@ -139,6 +139,8 @@
     } while (false)
 #endif
 
+#if !defined(SK_R32_SHIFT) || !defined(SK_G32_SHIFT) || !defined(SK_B32_SHIFT) || !defined(SK_A32_SHIFT)
+
 // If SK_R32_SHIFT is set, we'll use that to choose RGBA or BGRA.
 // If not, we'll default to RGBA everywhere except BGRA on Windows.
 #if defined(SK_R32_SHIFT)
@@ -158,6 +160,8 @@
 #define SK_G32_SHIFT 8
 #define SK_A32_SHIFT 24
 
+#endif
+
 /**
  * SkColor has well defined shift values, but SkPMColor is configurable. This
  * macro is a convenience that returns true if the shift values are equal while
-- 
2.26.2


From acd17f8caca3bda459132acc5cf2d7f1ddf1c89f Mon Sep 17 00:00:00 2001
From: Marcus Comstedt <marcus@mc.pp.se>
Date: Wed, 6 Jan 2021 13:48:12 +0100
Subject: [PATCH 13/13] Fix SkNx::FromBits to not rely on little endian

The old implementation used memcpy between integers of different size,
giving rise to different behaviour depending on host endianness.
This new imlementation mirrors the ToBits implementation in that memcpy
is only used when floats are involved, and then only between objects
of the same size.
---
 .../third_party/skia/include/private/SkNx.h        | 14 ++++++++++----
 1 file changed, 10 insertions(+), 4 deletions(-)

diff --git a/src/3rdparty/chromium/third_party/skia/include/private/SkNx.h b/src/3rdparty/chromium/third_party/skia/include/private/SkNx.h
index 240f4f4db..6cf29a257 100644
--- a/src/3rdparty/chromium/third_party/skia/include/private/SkNx.h
+++ b/src/3rdparty/chromium/third_party/skia/include/private/SkNx.h
@@ -286,13 +286,19 @@ private:
 
     template <typename Bits>
     AI static T FromBits(Bits bits) {
-        static_assert(std::is_pod<T   >::value &&
-                      std::is_pod<Bits>::value &&
-                      sizeof(T) <= sizeof(Bits), "");
         T val;
-        memcpy(&val, &bits, sizeof(T));
+        FromBits(val, bits);
         return val;
     }
+    template <typename U, typename Bits>
+    AI static void FromBits(U& v, Bits bits) {
+        static_assert(std::is_integral<U   >::value &&
+                      std::is_integral<Bits>::value);
+        v = bits;
+    }
+    AI static void FromBits(float& v, int32_t bits)  { memcpy(&v, &bits, sizeof(v)); }
+    AI static void FromBits(double& v, int64_t bits) { memcpy(&v, &bits, sizeof(v)); }
+
 };
 
 // Allow scalars on the left or right of binary operators, and things like +=, &=, etc.
-- 
2.26.2

